<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mathjax配置问题</title>
      <link href="/2019/mathjax%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2019/mathjax%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>使用hexo时，想要实现网页中公式的渲染<br>发现不管怎么改，都不能渲染单行公式<br>最后发现是在mathjax的2.3版本以后，配置方法变了</p><h3 id="mathjax的配置方法"><a href="#mathjax的配置方法" class="headerlink" title="mathjax的配置方法"></a>mathjax的配置方法</h3><p>一般网上大部分的mathjax的配置如下</p><pre><code class="lang-html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  });&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;path-to-MathJax/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;</code></pre><p>其中配置中这一句主要是增加对单行公式的渲染</p><pre><code class="lang-javascript">inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],</code></pre><p>有时候会发现无论如修改单行公式总是不能渲染<br>原因是在mathjax的2.3版本以后，应该这样配置</p><pre><code class="lang-html">&lt;script type=&quot;text/javascript&quot;&gt;  window.MathJax = {    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  };&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;path-to-MathJax/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1,<a href="https://docs.mathjax.org/en/latest/configuration.html" target="_blank" rel="noopener">https://docs.mathjax.org/en/latest/configuration.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch使用和损失函数</title>
      <link href="/2019/pytorch%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2019/pytorch%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="激励函数"><a href="#激励函数" class="headerlink" title="激励函数"></a>激励函数</h2><pre><code class="lang-python">#激活函数x=np.arange(-12.5,12.5,0.05)tanh = (np.power(np.e,x)-np.power(np.e,-x))/(np.power(np.e,x)+np.power(np.e,-x))relu = np.maximum(0.0,x)sigmoid = 1.0/(1.0+np.power(np.e,-x))</code></pre><pre><code class="lang-python">torch.nn.Sigmoid()</code></pre><script type="math/tex; mode=display">Sigmoid(x)=\frac {1}{1+e^{-x}}</script><script type="math/tex; mode=display">\frac {1}{1+e^{-x}}-\frac{1}{2}=\frac{1-e^{-x}}{2(1+e^{-x})}=-\frac{1-e^x}{2(1+e^x)}</script><pre><code class="lang-python">torch.nn.Tanh</code></pre><script type="math/tex; mode=display">Tanh(x)=tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}</script><script type="math/tex; mode=display">\frac{e^x-e^{-x}}{e^x+e^{-x}}=\frac{1-e^{-2x}}{1+e^{-2x}}=\frac{2}{1+e^{-2x}}-1=2Sigmoid(2x)-1</script><p>BatchNorm2d</p><p>对每一个特征进行正则</p><script type="math/tex; mode=display">y=\frac {x-E[x]} {\sqrt{Var[x]+\varepsilon}}*\gamma+\beta \ \ \ \ \ (\varepsilon=10^{-5})</script><p>pytorch中的正则化函数</p><pre><code class="lang-python">torch.nn.functional.normalize(input, p=2, dim=1, eps=1e-12, out=None)</code></pre><script type="math/tex; mode=display">v=\frac {v}{max(\lVert v \rVert_p,\varepsilon)}</script><pre><code class="lang-python">torch.norm(input, p=&#39;fro&#39;, dim=None, keepdim=False, out=None, dtype=None)# 对维度dim求p范数</code></pre><pre><code class="lang-python">torch.Tensor.squeeze()-&gt;Tensor#维度压缩torch.cat(tensors, dim=0, out=None)-&gt;Tensor #维度拼接torch.stack(tensors,dim=0,out=None)-&gt;Tensor #张量拼接# cat是把多张纸拼成一张纸,stack是把纸摞起来torch.Tensor.repeat()-&gt;Tensor #矩阵扩展torch.Tensor.transpose()-&gt;Tensor #矩阵转置torch.eq() #张量比较torch.chunk() #张量分块torch.split(tensor, split_size_or_sections, dim=0) #张量分块</code></pre><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="L1Loss"><a href="#L1Loss" class="headerlink" title="L1Loss"></a>L1Loss</h3><pre><code class="lang-python">torch.nn.L1Loss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\ell(x, y) = L = \{l_1,\dots,l_N\}^\top, \quad        l_n = \left| x_n - y_n \right|,</script><script type="math/tex; mode=display">        \ell(x, y) =        \begin{cases}            \operatorname{mean}(L), & \text{if reduction} = \text{'mean';}\\            \operatorname{sum}(L),  & \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss"></a>MSELoss</h3><pre><code class="lang-python">torch.nn.MSELoss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\ell(x, y) = L = \{l_1,\dots,l_N\}^\top, \quad        l_n = \left( x_n - y_n \right)^2,</script><script type="math/tex; mode=display">\ell(x, y) =        \begin{cases}            \operatorname{mean}(L), &  \text{if reduction} = \text{'mean';}\\            \operatorname{sum}(L),  &  \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="CrossEntropyLoss"><a href="#CrossEntropyLoss" class="headerlink" title="CrossEntropyLoss"></a>CrossEntropyLoss</h3><p>交叉熵损失函数,多分类</p><pre><code class="lang-python">torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, class) = -\log\left(\frac{\exp(x[class])}{\sum_j \exp(x[j])}\right)                       = -x[class] + \log\left(\sum_j \exp(x[j])\right)</script><script type="math/tex; mode=display">        \text{loss}(x, class) = weight[class] \left(-x[class] + \log\left(\sum_j \exp(x[j])\right)\right)</script><pre><code class="lang-python">torch.nn.CTCLoss(blank=0, reduction=&#39;mean&#39;, zero_infinity=False)</code></pre><h3 id="NLLLoss"><a href="#NLLLoss" class="headerlink" title="NLLLoss"></a>NLLLoss</h3><p>负对数似然损失函数(Negative Loss Likelihood),多分类</p><pre><code class="lang-python">torch.nn.NLLLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\ell(x, y) = L = \{l_1,\dots,l_N\}^\top, \quad        l_n = - w_{y_n} x_{n,y_n}, \quad        w_{c} = \text{weight}[c] \cdot \mathbb{1}\{c \not= \text{ignore_index}\},</script><script type="math/tex; mode=display">        \ell(x, y) = \begin{cases}            \sum_{n=1}^N \frac{1}{\sum_{n=1}^N w_{y_n}} l_n, &            \text{if reduction} = \text{'mean';}\\            \sum_{n=1}^N l_n,  &            \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="PoissonNLLLoss"><a href="#PoissonNLLLoss" class="headerlink" title="PoissonNLLLoss"></a>PoissonNLLLoss</h3><pre><code class="lang-python">torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{target} \sim \mathrm{Poisson}(\text{input})        \text{loss}(\text{input}, \text{target}) = \text{input} - \text{target} * \log(\text{input})                                    + \log(\text{target!})</script><h3 id="KLDivLoss"><a href="#KLDivLoss" class="headerlink" title="KLDivLoss"></a>KLDivLoss</h3><p>KL散度,又叫相对熵,计算两个分布之间的距离,越相近越接近零</p><pre><code class="lang-python">torch.nn.KLDivLoss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">        l(x,y) = L = \{ l_1,\dots,l_N \}, \quad        l_n = y_n \cdot \left( \log y_n - x_n \right)</script><script type="math/tex; mode=display">\ell(x, y) = \begin{cases}            \operatorname{mean}(L), & \text{if reduction} = \text{'mean';} \\            \operatorname{sum}(L),  & \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="BCELoss"><a href="#BCELoss" class="headerlink" title="BCELoss"></a>BCELoss</h3><p>二分类用的交叉熵</p><pre><code class="lang-python">torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">        \ell(x, y) = L = \{l_1,\dots,l_N\}^\top, \quad        l_n = - w_n \left[ y_n \cdot \log x_n + (1 - y_n) \cdot \log (1 - x_n) \right],</script><script type="math/tex; mode=display">\ell(x, y) = \begin{cases}            \operatorname{mean}(L), & \text{if reduction} = \text{'mean';}\\            \operatorname{sum}(L),  & \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="BCEWithLogitsLoss"><a href="#BCEWithLogitsLoss" class="headerlink" title="BCEWithLogitsLoss"></a>BCEWithLogitsLoss</h3><p>增加了一个Sigmoid层</p><pre><code class="lang-python">torch.nn.BCEWithLogitsLoss(weight=None, size_average=None, reduce=None, reduction=&#39;mean&#39;, pos_weight=None)</code></pre><script type="math/tex; mode=display">\ell(x, y) = L = \{l_1,\dots,l_N\}^\top, \quad        l_n = - w_n \left[ y_n \cdot \log \sigma(x_n)        + (1 - y_n) \cdot \log (1 - \sigma(x_n)) \right],</script><script type="math/tex; mode=display">        \ell(x, y) = \begin{cases}            \operatorname{mean}(L), & \text{if reduction} = \text{'mean';}\\            \operatorname{sum}(L),  & \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="MarginRankingLoss"><a href="#MarginRankingLoss" class="headerlink" title="MarginRankingLoss"></a>MarginRankingLoss</h3><p>评价相似度的损失</p><pre><code class="lang-python">torch.nn.MarginRankingLoss(margin=0.0, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, y) = \max(0, -y * (x1 - x2) + \text{margin})</script><h3 id="HingeEmbeddingLoss"><a href="#HingeEmbeddingLoss" class="headerlink" title="HingeEmbeddingLoss"></a>HingeEmbeddingLoss</h3><p>用于学习非线性嵌入或半监督学习</p><pre><code class="lang-python">torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">L = \{l_1,\dots,l_N\}^\top, \quadl_n = \begin{cases}            x_n, & \text{if}\; y_n = 1,\\            \max \{0, \Delta - x_n\}, & \text{if}\; y_n = -1,        \end{cases}</script><script type="math/tex; mode=display">        \ell(x, y) = \begin{cases}            \operatorname{mean}(L), & \text{if reduction} = \text{'mean';}\\            \operatorname{sum}(L),  & \text{if reduction} = \text{'sum'.}        \end{cases}</script><h3 id="MultiLabelMarginLoss"><a href="#MultiLabelMarginLoss" class="headerlink" title="MultiLabelMarginLoss"></a>MultiLabelMarginLoss</h3><p>多类别多分类的Hinge损失</p><pre><code class="lang-python">torch.nn.MultiLabelMarginLoss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, y) = \sum_{ij}\frac{\max(0, 1 - (x[y[j]] - x[i]))}{\text{x.size}(0)}</script><p>其中$x \in \left{0, \; \cdots , \; \text{x.size}(0) - 1\right}$,$y \in \left{0, \; \cdots , \; \text{y.size}(0) - 1\right}$,$0 \leq y[j] \leq \text{x.size}(0)-1$,$i \neq y[j]$</p><h3 id="SmoothL1Loss"><a href="#SmoothL1Loss" class="headerlink" title="SmoothL1Loss"></a>SmoothL1Loss</h3><p>也叫Huber Loss,误差在(-1,1)上是平方损失,其他情况是L1损失</p><pre><code class="lang-python">torch.nn.SmoothL1Loss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, y) = \frac{1}{n} \sum_{i} z_{i}</script><script type="math/tex; mode=display">z_{i} =        \begin{cases}        0.5 (x_i - y_i)^2, & \text{if } |x_i - y_i| < 1 \\        |x_i - y_i| - 0.5, & \text{otherwise }        \end{cases}</script><h3 id="SoftMarginLoss"><a href="#SoftMarginLoss" class="headerlink" title="SoftMarginLoss"></a>SoftMarginLoss</h3><p>多标签二分类问题</p><pre><code class="lang-python">torch.nn.SoftMarginLoss(size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, y) = \sum_i \frac{\log(1 + \exp(-y[i]*x[i]))}{\text{x.nelement}()}</script><h3 id="MultiLabelSoftMarginLoss"><a href="#MultiLabelSoftMarginLoss" class="headerlink" title="MultiLabelSoftMarginLoss"></a>MultiLabelSoftMarginLoss</h3><p>多标签多分类</p><pre><code class="lang-python">torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">        loss(x, y) = - \frac{1}{C} * \sum_i y[i] * \log((1 + \exp(-x[i]))^{-1})                         + (1-y[i]) * \log\left(\frac{\exp(-x[i])}{(1 + \exp(-x[i]))}\right)</script><p>其中$i \in \left{0, \; \cdots , \; \text{x.nElement}() - 1\right}$,$y[i] \in \left{0, \; 1\right}$</p><h3 id="CosineEmbeddingLoss"><a href="#CosineEmbeddingLoss" class="headerlink" title="CosineEmbeddingLoss"></a>CosineEmbeddingLoss</h3><p>余玄相似度损失</p><pre><code class="lang-python">torch.nn.CosineEmbeddingLoss(margin=0.0, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">        \text{loss}(x, y) =        \begin{cases}        1 - \cos(x_1, x_2), & \text{if } y = 1 \\        \max(0, \cos(x_1, x_2) - \text{margin}), & \text{if } y = -1        \end{cases}</script><h3 id="MultiMarginLoss"><a href="#MultiMarginLoss" class="headerlink" title="MultiMarginLoss"></a>MultiMarginLoss</h3><p>多分类的Hinge损失</p><pre><code>torch.nn.MultiMarginLoss(p=1, margin=1.0, weight=None, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">\text{loss}(x, y) = \frac{\sum_i \max(0, (\text{margin} - x[y] + x[i])^p)}{\text{x.size}(0)}</script><p>其中$x \in \left{0, \; \cdots , \; \text{x.size}(0) - 1\right}$,$i \neq y$</p><script type="math/tex; mode=display">\text{loss}(x, y) = \frac{\sum_i \max(0, w[y] * (\text{margin} - x[y] + x[i])^p)}{\text{x.size}(0)}</script><h3 id="TripletMarginLoss"><a href="#TripletMarginLoss" class="headerlink" title="TripletMarginLoss"></a>TripletMarginLoss</h3><pre><code class="lang-python">torch.nn.TripletMarginLoss(margin=1.0, p=2.0, eps=1e-06, swap=False, size_average=None, reduce=None, reduction=&#39;mean&#39;)</code></pre><script type="math/tex; mode=display">L(a, p, n) = \max \{d(a_i, p_i) - d(a_i, n_i) + {\rm margin}, 0\}</script><script type="math/tex; mode=display">d(x_i, y_i) = \left\lVert {\bf x}_i - {\bf y}_i \right\rVert_p</script>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 损失函数 </tag>
            
            <tag> tensor变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见损失函数</title>
      <link href="/2019/%E5%B8%B8%E8%A7%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2019/%E5%B8%B8%E8%A7%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-损失函数"><a href="#1-损失函数" class="headerlink" title="1.损失函数"></a>1.损失函数</h3><blockquote><p><strong>损失函数</strong>是指一种将一个事件（在一个<a href="https://wiki.mbalib.com/wiki/%E6%A0%B7%E6%9C%AC" target="_blank" rel="noopener">样本</a>空间中的一个元素）映射到一个表达与其事件<a href="https://wiki.mbalib.com/wiki/%E7%9B%B8%E5%85%B3" target="_blank" rel="noopener">相关</a>的<a href="https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E6%88%90%E6%9C%AC" target="_blank" rel="noopener">经济成本</a>或<a href="https://wiki.mbalib.com/wiki/%E6%9C%BA%E4%BC%9A%E6%88%90%E6%9C%AC" target="_blank" rel="noopener">机会成本</a>的实数上的一种函数,较常运用在<a href="https://wiki.mbalib.com/wiki/%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">统计学</a>，<a href="https://wiki.mbalib.com/wiki/%E7%BB%9F%E8%AE%A1%E5%86%B3%E7%AD%96%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">统计决策理论</a>和<a href="https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6" target="_blank" rel="noopener">经济学</a>中。损失函数参数的真值为（θ），<a href="https://wiki.mbalib.com/wiki/%E5%86%B3%E7%AD%96" target="_blank" rel="noopener">决策</a>的结果为<em>d</em> ，两者的不一致会带来一定的损失，这种损失是一个<a href="https://wiki.mbalib.com/wiki/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">随机变量</a>，用<em>L</em>(θ,<em>d</em>)表示。</p></blockquote><h4 id="1-1-0-1损失函数-0-1-loss-function"><a href="#1-1-0-1损失函数-0-1-loss-function" class="headerlink" title="1.1 0-1损失函数(0-1 loss function)"></a>1.1 0-1损失函数(0-1 loss function)</h4><script type="math/tex; mode=display">L(Y,f(X))=\begin{cases}1,Y \neq f(X)\\0,Y = f(X)\end{cases}</script><h4 id="1-2平方损失函数-quadratic-loss-function"><a href="#1-2平方损失函数-quadratic-loss-function" class="headerlink" title="1.2平方损失函数(quadratic loss function)"></a>1.2平方损失函数(quadratic loss function)</h4><script type="math/tex; mode=display">L(Y,f(X))=(Y-f(X))^2</script><h4 id="1-3绝对损失函数-absolute-loss-function"><a href="#1-3绝对损失函数-absolute-loss-function" class="headerlink" title="1.3绝对损失函数(absolute loss function)"></a>1.3绝对损失函数(absolute loss function)</h4><script type="math/tex; mode=display">L(Y,f(X))=|Y-f(X)|</script><h4 id="1-4对数损失函数-logarithmic-loss-function-或对数似然损失函数-log-likelihood-loss-function"><a href="#1-4对数损失函数-logarithmic-loss-function-或对数似然损失函数-log-likelihood-loss-function" class="headerlink" title="1.4对数损失函数(logarithmic loss function)或对数似然损失函数(log likelihood loss function)"></a>1.4对数损失函数(logarithmic loss function)或对数似然损失函数(log likelihood loss function)</h4><script type="math/tex; mode=display">L(Y,P(Y|X))=-logP(Y|X)</script><h3 id="2-风险函数"><a href="#2-风险函数" class="headerlink" title="2.风险函数"></a>2.风险函数</h3><p><strong>风险函数</strong>是损失函数的期望值，表示为：</p><script type="math/tex; mode=display">R(\theta,d)=E[L(d,\theta)]*R*(θ,*d*) = *E*[*L*(*d*,θ)]。</script><p>决策的目标是要找出一个决策方案$d$，使其对各个自然状态风险值均为最小。应用时，常常对θ(参数的真值)确定一个概率分布，并使其平均的风险值$r(d,\theta)$达到最小，其中：</p><script type="math/tex; mode=display">r(d,\theta) = E[R(d,\theta)]=\sum_{j=1}^LR(d,\theta)p(\theta_j)</script><p>有结构风险函数和经验风险函数</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1,<a href="http://www.csuldw.com/2016/03/26/2016-03-26-loss-function/" target="_blank" rel="noopener">http://www.csuldw.com/2016/03/26/2016-03-26-loss-function/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络中的前向传播与后向传播</title>
      <link href="/2019/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%90%8E%E5%90%91%E4%BC%A0%E6%92%AD/"/>
      <url>/2019/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%90%8E%E5%90%91%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2019/7_10_neu.png" alt="img"></p><p>$f(z)$为激励函数，关于激励函数(又称激活函数)的总结<br>隐藏层1输入</p><script type="math/tex; mode=display">z^{(1)}=W^{(1)}x^T+b^{(1)}\label{1}\tag{1}</script><p>隐藏层1输出</p><script type="math/tex; mode=display">n^{(1)}=f^{(1)}(z^{(1)})\label{2}\tag{2}</script><p>隐藏层2输入</p><script type="math/tex; mode=display">z^{(2)}=W^{(2)}n^{(1)}+b^{(2)}\label{3}\tag{3}</script><p>隐藏层2输出</p><script type="math/tex; mode=display">n^{(2)}=f^{(2)}(z^{(2)})\label{4}\tag{4}</script><p>隐藏层3输入</p><script type="math/tex; mode=display">z^{(3)}=W^{(3)}n^{(2)}+b^{(3)}\label{5}\tag{5}</script><p>隐藏层3输出即输出层</p><script type="math/tex; mode=display">\widehat y = n^{(3)}= f^{(3)}(z{(3)})\label{6}\tag{6}</script><p>损失函数</p><script type="math/tex; mode=display">L(y,\widehat y)\label{7}\tag{7}</script><p>即隐藏层k+1输入</p><script type="math/tex; mode=display">z^{(k+1)}=W^{(k+1)}n^{(k)}+b^{(k+1)}\label{8}\tag{8}</script><p>隐藏层k+1输出</p><script type="math/tex; mode=display">n^{(k+1)}= f^{(k+1)}(z{(k+1)})\label{9}\tag{9}</script><p>对损失函数进行总结<a href="https://blog.csdn.net/lien0906/article/details/78429768" target="_blank" rel="noopener">https://blog.csdn.net/lien0906/article/details/78429768</a><br>计算偏导数</p><script type="math/tex; mode=display">\frac {\partial z^{(k)}}{\partial b^{(k)}}=\begin{bmatrix}\frac{\partial (W^{(k)}_{[1,:]}*n^{(k-1)}+b_1)}{\partial b_1} & \ldots & \frac{\partial (W^{(k)}_{[1,:]}*n^{(k-1)}+b_1)}{\partial b_m}\\\vdots & \ddots & \vdots\\\frac{\partial (W^{(k)}_{[m,:]}*n^{(k-1)}+b_m)}{\partial b_1}  &\ldots & \frac{\partial (W^{(k)}_{[m,:]}*n^{(k-1)}+b_m)}{\partial b_m}\end{bmatrix}=diag(1,1, \ldots ,1)\label{10}\tag{10}</script><p>列向量对列向量求导参见矩阵中的求导</p><p>计算偏导数$\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}​$ </p><p>偏导数$\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}$ 又称误差项(error term,也称“灵敏度”),一般用$\delta$ 表示,用$\delta^{(k)}$ 表示第k层神经元的误差项,其值的大小代表了<strong>第k层神经元对最终总误差的影响大小</strong> </p><script type="math/tex; mode=display">\begin{align}\delta^{(k)} & = \frac {\partial L(y,\widehat y)}{\partial z^{(k)}}\\& =\frac {\partial n^{(k)}}{\partial z^{(k)}}*\frac {\partial z^{(k+1)}}{\partial n^{(k)}}*\frac {\partial L(y,\widehat y)}{\partial z^{(k+1)}}\\& = {f^{(k)}}^{'}(z^{(k)}) * (W^{(k+1)})^T * \delta^{(k+1)}\end{align}\label{11}\tag{11}</script><p>最终需要用的两个导数</p><script type="math/tex; mode=display">\frac {\partial L(y,\widehat y)}{\partial W^{(k)}}=\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}*\frac {\partial z^{(k)}}{\partial W^{(k)}}=\delta^{(k)}*(n^{(k-1)})^T\label{12}\tag{12}</script><script type="math/tex; mode=display">\frac {\partial L(y,\widehat y)}{\partial b^{(k)}}=\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}*\frac {\partial z^{(k)}}{\partial b^{(k)}}=\delta^{(k)}\label{13}\tag{13}</script><p>后向传播参数更新</p><script type="math/tex; mode=display">W^{(k)} = W^{(k)} - \alpha(\delta^{(k)}(n^{(k-1)})^T + W^{(k)})\label{14}\tag{14}\\</script><script type="math/tex; mode=display">b^{(k)} = b^{(k)}-\alpha\delta^{(k)}\label{15}\tag{15}</script><p>其中$\alpha$ 是学习率</p><p>后向传播中的正则化,L1正则化,L2正则化</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中Keras vs Pytorch</title>
      <link href="/2019/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADKeras%20vs%20Pytorch/"/>
      <url>/2019/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADKeras%20vs%20Pytorch/</url>
      
        <content type="html"><![CDATA[<p>深度学习框架Keras与Pytorch的区别与优劣<a href="https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d" target="_blank" rel="noopener">翻译</a><br><img src="/images/2019/7_11_pytorchvskears.png" alt="img" title="Keras vs PyTorch"></p><p>对于许多科学家，工程师和开发人员来说，TensorFlow是他们的第一个深度学习框架。 TensorFlow 1.0于2017年2月发布;但它对用户来说不是很友好。</p><p>在过去几年中，两个主要的深度学习库已经获得了巨大的普及，主要是因为它们比TensorFlow更容易使用：<strong>Keras</strong>和<strong>Pytorch</strong>。</p><p>本文将介绍Keras与Pytorch的4个不同点，以及为什么您可以选择一个库而不是另一个库。</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>Keras本身不是一个框架，但实际上是一个位于其他Deep Learning框架之上的高级API。目前它支持<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>，<a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a>和<a href="https://github.com/microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>。</p><p>Keras的优势在于它的易用性。它是迄今为止最容易去快速启动和运行的框架。定义神经网络非常直观，使用功能API允许人们将层定义为函数。</p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><p>Pytorch是由Facebook的AI研究小组开发的深度学习框架（如TensorFlow）。像Keras一样，它也对深度网络编程中比较复杂的一大部分进行了抽象。</p><p>在高级和低级编码风格方面，Pytorch位于Keras和TensorFlow之间。你比Keras有更多的灵活性和控制力，但与此同时你不必做任何疯狂的声明性编程。</p><p>深度学习练习者整天都在争论应该使用哪个框架。一般来说，这取决于个人喜好。但是在选择时你应该记住Keras和Pytorch的一些特性。</p><p><img src="/images/2019/7_10_keras.jpeg" alt="img" title="It&#39;s keras"></p><p><img src="/images/2019/7_10_pytorch.jpeg" alt="img" title="It&#39;s Pytorch!"></p><h2 id="1-用于定义模型的-类-Pytorch-vs-函数-Keras"><a href="#1-用于定义模型的-类-Pytorch-vs-函数-Keras" class="headerlink" title="(1)用于定义模型的 类(Pytorch) vs 函数(Keras)"></a>(1)用于定义模型的 类(Pytorch) vs 函数(Keras)</h2><p>要定义深度学习模型，Keras提供Functional API。 使用Functional API，神经网络被定义为一组顺序函数，一个接一个地应用。 例如，第一层的输出是第二层的输入。</p><pre><code class="lang-python">img_input = layers.Input(shape=input_shape)x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(img_input)    x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(x)    x = layers.MaxPooling2D((2, 2), strides=(2, 2))(x)</code></pre><p>在Pytorch中，您将网络设置为一个类，该类继承了Torch库中的torch.nn.Module。 与Keras类似，Pytorch为您提供了层作为构建块，但由于它们位于Python类中，因此它们在类的__init__()方法中引用，并由类的forward()方法执行。</p><pre><code class="lang-python">class Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(3, 64, 3)        self.conv2 = nn.Conv2d(64, 64, 3)        self.pool = nn.MaxPool2d(2, 2)    def forward(self, x):        x = F.relu(self.conv1(x))        x = self.pool(F.relu(self.conv2(x)))        return xmodel = Net()</code></pre><p>因为Pytorch允许您访问所有Python的类功能而不是简单的函数调用，所以定义网络可以更清晰，更优雅地包含。 这真的没什么不好的，除非你觉得最重要的是尽可能快地编写代码，那么Keras会更容易使用。</p><h2 id="2-张量和计算图-Pytorch-vs-标准阵列-Keras"><a href="#2-张量和计算图-Pytorch-vs-标准阵列-Keras" class="headerlink" title="(2)张量和计算图(Pytorch) vs 标准阵列(Keras)"></a>(2)张量和计算图(Pytorch) vs 标准阵列(Keras)</h2><p>Keras API对程序员隐藏了的许多复杂细节。定义网络层非常直观，默认设置通常足以让您入门。</p><p>只有当你需要实现一个相当尖端或“异国情调”的模型时，你才真正需要去了解底层的TensorFlow。</p><p>棘手的部分是，当你真正去了解底层的TensorFlow代码时，你将获得随之而来的所有非常具有挑战性的部分！ 您需要确保所有矩阵乘法都排成一行。 哦，甚至不要去考虑尝试打印出图层的一个输出，因为您只能在终端上打印出一个漂亮的Tensor定义。</p><p>Pytorch在这些方面倾向于更加方便。 您需要知道每个层的输入和输出大小，但这可以很快掌握。 您不必处理构建一个您无法在调试中看到的抽象计算图。</p><p>Pytorch的另一个好处是你可以在Torch Tensors和Numpy阵列之间来回滑动。 如果你需要实现自定义的东西，那么在TF张量和Numpy阵列之间来回转换可能会很麻烦，需要开发人员对TensorFlow的Session有充分的了解。</p><p>Pytorch的交互性比想象中要简单得多。 您只需要知道两个操作：一个将Torch Tensor（一个Variable对象）转变到Numpy，另一个是相反的转换。</p><pre><code class="lang-python">a = torch.Tensor(2,2)print(a)b = a.numpy() #tensor 变为numpyprint(b)print(torch.from_numpy(b)) # numpy 变为tensor</code></pre><p>当然，如果你不需要实现任何花哨的东西，那么Keras会做得很好，因为你不会遇到任何TensorFlow障碍。 但如果你这样做，那么Pytorch可能会更顺畅。</p><h2 id="3-Training-models"><a href="#3-Training-models" class="headerlink" title="(3) Training models"></a>(3) Training models</h2><p>在Keras训练模型非常容易！ 只是一个简单的.fit()函数，你可以很轻松的进行训练。</p><pre><code class="lang-python">history = model.fit_generator(    generator=train_generator,    epochs=10,    validation_data=validation_generator)</code></pre><p>在Pytorch中训练一些模型需要一些步骤</p><ul><li>每一批次的训练开始时初始化梯度</li><li>在模型中运行前向传播</li><li>运行后向传播</li><li>计算损失和更新权重</li></ul><p>所以，就训练模型来说，PyTorch 较为繁琐。</p><pre><code class="lang-python">for epoch in range(2):  # loop over the dataset multiple times    running_loss = 0.0    for i, data in enumerate(trainloader, 0):        # Get the inputs; data is a list of [inputs, labels]        inputs, labels = data        # (1) Initialise gradients        optimizer.zero_grad()        # (2) Forward pass        outputs = net(inputs)        loss = criterion(outputs, labels)        # (3) Backward        loss.backward()        # (4) Compute the loss and update the weights        optimizer.step()</code></pre><h2 id="4-控制-CPU-vs-GPU-模式"><a href="#4-控制-CPU-vs-GPU-模式" class="headerlink" title="(4)控制 CPU vs GPU 模式"></a>(4)控制 CPU vs GPU 模式</h2><p>如果你已经安装了 tensorflow-gpu，则在 Keras 中能够使用 GPU 并且会默认完成。然后，如果你想要将某些运算转移至 CPU，则可以以单行方式完成。</p><pre><code class="lang-python">with tf.device(&#39;/cpu:0&#39;):    y = apply_non_max_suppression(x)</code></pre><p>但对于 PyTorch 来说，你必须显式地为每个 torch 张量和 numpy 变量启动 GPU。这样代码会比较混乱。并且如果你想在 CPU 和 GPU 之间来回移动以执行不同运算，则很容易出错。</p><p>例如，为了将之前的模型转移到 GPU 上运行，则需要以下步骤：</p><pre><code class="lang-python"># Get the GPU devicedevice = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)# Transfer the network to GPUnet.to(device)# Transfer the inputs and labels to GPUinputs, labels = data[0].to(device), data[1].to(device)</code></pre><p>因而，Keras 在简洁性和默认设置方面优于 PyTorch。</p><h2 id="选择-Keras-或-PyTorch-的一般性建议"><a href="#选择-Keras-或-PyTorch-的一般性建议" class="headerlink" title="选择 Keras 或 PyTorch 的一般性建议"></a>选择 Keras 或 PyTorch 的一般性建议</h2><p>作者通常建议初学者从 Keras 开始。Keras 绝对是理解和使用起来最简单的框架，能够很快地上手运行。你完全不需要担心 GPU 设置、处理抽象代码以及其他任何复杂的事情。你甚至可以在不接触任何 TensorFlow 单行代码的情况下，实现自定义层和损失函数。</p><p>但如果你开始深度了解到深度网络的更细粒度层面或者正在实现一些非标准的事情，则 PyTorch 是你的首选库。使用 PyTorch 需要进行一些额外操作，但这不会减缓你的进程。你依然能够快速实现、训练和测试网络，并享受简单调试带来的额外益处。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keras </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化算法总结</title>
      <link href="/2019/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="AdaGrad-Adaptive-Gradient-自适应梯度"><a href="#AdaGrad-Adaptive-Gradient-自适应梯度" class="headerlink" title="AdaGrad(Adaptive Gradient)自适应梯度"></a>AdaGrad(Adaptive Gradient)自适应梯度</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><a id="more"></a><script type="math/tex; mode=display">\theta_{t+1} = \theta_t-\alpha\cdot g_t/\sqrt{\sum_{i=1}^tg_t^2} \ \ \ \ \ (\alpha=0.01)</script><p>随梯度的变化改变学习率</p><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><script type="math/tex; mode=display">v_t= \gamma(v_{t-1})+(1-\gamma)g_t^2 \ \ \ \ \ (\gamma=0.9)</script><script type="math/tex; mode=display">\theta_{t} = \theta_{t-1}-\alpha* g_t/(\sqrt v_t + \varepsilon) \ \ \ \ \ (\alpha=0.001,\varepsilon=10^{-8})</script><p>结合梯度平方的指数移动平均数来调节学习率的变化</p><p>克服AdaGrad梯度急剧减小的问题</p><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><script type="math/tex; mode=display">m_t = \beta_1m_{t-1}+(1-\beta_1)g_t \ \ \ \ \ (\beta_1=0.9,m_0=0)</script><script type="math/tex; mode=display">v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2 \ \ \ \ \ (\beta_2=0.999,v_0=0)</script><script type="math/tex; mode=display">\hat m_t = m_t/(1-\beta_1^t)</script><script type="math/tex; mode=display">\hat v_t = v_t/(1-\beta_2^t)</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1}-\alpha * \hat m_t/(\hat v_t + \varepsilon) \ \ \ \ \ (\alpha=0.001,\varepsilon=10^{-8})</script><p>对梯度的一阶矩估计（First Moment Estimation，即梯度的均值）和二阶矩估计（Second</p><p>Moment Estimation，即梯度的未中心化的方差）进行综合考虑，计算出更新步长。</p><h3 id="下面是对几种梯度下降算法的模拟"><a href="#下面是对几种梯度下降算法的模拟" class="headerlink" title="下面是对几种梯度下降算法的模拟"></a>下面是对几种梯度下降算法的模拟</h3><p>其中包括随机梯度下降算法SGD，小批量梯度下降算法MSGD，批量梯度下降算法BGD</p><p>都是根据损失函数计算参数梯度，更新参数;不一样的地方是他们使用使用训练集的方式</p><pre><code class="lang-python"># 随机梯度下降算法SGDx=np.random.rand(10000,5)w=np.array([[1,2,3,4,5],[20,30,40,50,60]])b=np.array([[10],[100]])y=(w.dot(x.T)+b).T #100,2lr=0.5ww = np.random.rand(2,5)bb = np.random.rand(2,1)mb=master_bar(range(1000000))mb.names=[&#39;loss&#39;]lossy=[]for i in mb:    r=np.random.randint(1000)    xi=x[r:r+1,:] #1,5    yi=y[r:r+1,:] #1,2    yy = ww.dot(xi.T)+bb #2,1    loss = np.mean(np.power(yy-yi.T,2)/2)    lossy.append(loss)    graphs = [[np.arange(len(lossy)),lossy]]    mb.update_graph(graphs)    ww=  ww - lr*(yy-yi.T).dot(xi)    bb=  bb - lr*(yy-yi.T)    if loss &lt; 1e-10:        break    #print(loss)print(ww,bb)print(w,b)# 小批量梯度下降算法MSGDx=np.random.rand(1000,5)w=np.array([[1,2,3,4,5],[20,30,40,50,60]])b=np.array([[10],[100]])y=(w.dot(x.T)+b).T #100,2lr=0.3ww = np.random.rand(2,5)bb = np.random.rand(2,1)mb=master_bar(range(200*3))mb.names=[&#39;loss&#39;]lossy=[]batch = 50for i in mb:    lossg,wwg,bbg=0,0,0    for j in progress_bar(range(batch),parent=mb):        r=np.random.randint(1000)        xi=x[r:r+1,:] #1,5        yi=y[r:r+1,:] #1,2        yy = ww.dot(xi.T)+bb #2,10        lossg += np.mean(np.power(yy-yi.T,2)/2)        wwg += (yy-yi.T).dot(xi)        bbg += (yy-yi.T)    lossy.append(lossg/batch)    graphs = [[np.arange(len(lossy)),lossy]]    mb.update_graph(graphs)    ww=  ww - lr*wwg/batch    bb=  bb - lr*bbg/batch    if lossg/batch &lt; 1e-4:        break    #print(loss)print(ww,bb)print(w,b)# 批量梯度下降算法BGDx=np.random.rand(1000,5)w=np.array([[1,2,3,4,5],[20,30,40,50,60]])b=np.array([[10],[100]])y=(w.dot(x.T)+b).T #100,2lr=0.3#ww = np.random.rand(2,5)#bb = np.random.rand(2,1)mb=master_bar(range(200*3))mb.names=[&#39;loss&#39;]lossy=[]batch = 1000for i in mb:    lossg,wwg,bbg=0,0,0    for j in progress_bar(range(batch),parent=mb):        r=j        xi=x[r:r+1,:] #1,5        yi=y[r:r+1,:] #1,2        yy = ww.dot(xi.T)+bb #2,10        lossg += np.mean(np.power(yy-yi.T,2)/2)        wwg += (yy-yi.T).dot(xi)        bbg += (yy-yi.T)    lossy.append(lossg/batch)    graphs = [[np.arange(len(lossy)),lossy]]    mb.update_graph(graphs)    ww=  ww - lr*wwg/batch    bb=  bb - lr*bbg/batch    if lossg/batch &lt; 1e-4:        break    #print(loss)print(ww,bb)print(w,b)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AdaGrad </tag>
            
            <tag> RMSProp </tag>
            
            <tag> Adam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中遇到的问题</title>
      <link href="/2019/python%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/python%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-列表的初始化"><a href="#1-列表的初始化" class="headerlink" title="1.列表的初始化"></a>1.列表的初始化</h3><p>当初始化一个n×n的列表时不能使用如下方法，</p><pre><code class="lang-python">In [1]: l=[[0]*3]*3 #如此初始化会导致其它行仅是第一行的引用而不是copyIn [2]: lOut[2]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]In [3]: l[0][0]=1 #改变其中一行的某个元素In [4]: lOut[4]: [[1, 0, 0], [1, 0, 0], [1, 0, 0]] #其他行跟着改变</code></pre><p>正确的方法应该如下</p><pre><code class="lang-python">In [5]: l=[[0 for _ in range(3)] for _ in range(3)] #或者l=[[0]*3 for _ in range(3)]In [6]: lOut[6]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]In [7]: l[0][0]=1In [8]: lOut[8]: [[1, 0, 0], [0, 0, 0], [0, 0, 0]]</code></pre><h3 id="2-a-is-b与a-b-的区别"><a href="#2-a-is-b与a-b-的区别" class="headerlink" title="2.a is b与a==b 的区别"></a>2.a is b与a==b 的区别</h3><pre><code>a=&#39;vhcffh.com&#39;b=&#39;vhcffh.com&#39;a==b # True,a和b对应实例的内容是相同的a is b # False,a和b指向不同的实例b=aa is b # True,a和b指向同一个实例</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python常用方法</title>
      <link href="/2019/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-sorted排序"><a href="#1-sorted排序" class="headerlink" title="1.sorted排序"></a>1.sorted排序</h3><pre><code class="lang-python">sorted(iterable[, cmp[, key[, reverse]]])</code></pre><p>参数说明：</p><ul><li>iterable — 可迭代对象。</li><li>cmp — 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li><li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse — 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Linux中的一些常用命令,tar<br><a id="more"></a></p><h2 id="1-tar解压打包相关"><a href="#1-tar解压打包相关" class="headerlink" title="1.tar解压打包相关"></a>1.tar解压打包相关</h2><pre><code class="lang-shell">tar -cvf log.tar log2019.log    #仅打包，不压缩tar -zcvf log.tar.gz log2019.log   #打包后，以 gzip 压缩tar -jcvf log.tar.bz2 log2019.log  #打包后，以 bzip2 压缩tar -ztvf log.tar.gz #gzip查阅tar -jtvf log.tar.gz #bzip2查阅tar -zxvf log.tar.gz #gzip解压tar -jxvf log.tar.gz #bzip2解压unzip log.zip -d dirname #zip解压到dirname目录</code></pre><p>补充</p><p>c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出 </p><h2 id="2-wget设置代理"><a href="#2-wget设置代理" class="headerlink" title="2.wget设置代理"></a>2.wget设置代理</h2><h3 id="2-1环境变量中设置"><a href="#2-1环境变量中设置" class="headerlink" title="2.1环境变量中设置"></a>2.1环境变量中设置</h3><pre><code class="lang-shell">export http_proxy=http://127.0.0.1:8087</code></pre><h3 id="2-2使用配置文件"><a href="#2-2使用配置文件" class="headerlink" title="2.2使用配置文件"></a>2.2使用配置文件</h3><pre><code class="lang-shell"># cp /etc/wgetrc ~/.wgetrc# vim ~/.wgetrc# You can set the default proxies for Wget to use for http, https, and ftp.# They will override the value in the environment.https_proxy = http://127.0.0.1:8087/http_proxy = http://127.0.0.1:8087/ftp_proxy = http://127.0.0.1:8087/# If you do not want to use proxy at all, set this to off.use_proxy = on</code></pre><h2 id="3-ps相关命令"><a href="#3-ps相关命令" class="headerlink" title="3.ps相关命令"></a>3.ps相关命令</h2><pre><code class="lang-shell">ps -ef # 查看进程信息和执行的命令</code></pre><h2 id="4-用户文件管理相关"><a href="#4-用户文件管理相关" class="headerlink" title="4.用户文件管理相关"></a>4.用户文件管理相关</h2><h3 id="4-1Linux系统用户账号的管理"><a href="#4-1Linux系统用户账号的管理" class="headerlink" title="4.1Linux系统用户账号的管理"></a>4.1Linux系统用户账号的管理</h3><h4 id="4-1-1添加新的用户账号"><a href="#4-1-1添加新的用户账号" class="headerlink" title="4.1.1添加新的用户账号"></a>4.1.1添加新的用户账号</h4><pre><code class="lang-shell">useradd [-d dirname] username# [-d dirname]指定用户主目录</code></pre><h4 id="4-1-2删除帐号"><a href="#4-1-2删除帐号" class="headerlink" title="4.1.2删除帐号"></a>4.1.2删除帐号</h4><pre><code class="lang-shell">userdel [-r] username# [-R]把用户的主目录一起删除</code></pre><h4 id="4-1-3修改帐号"><a href="#4-1-3修改帐号" class="headerlink" title="4.1.3修改帐号"></a>4.1.3修改帐号</h4><pre><code class="lang-shell">usermod [] username</code></pre><h4 id="4-1-4用户密码管理"><a href="#4-1-4用户密码管理" class="headerlink" title="4.1.4用户密码管理"></a>4.1.4用户密码管理</h4><pre><code class="lang-shell">passwd [-I][-u][-d][-f] username# [-I]锁定密码，即禁用账号。# [-u]密码解锁。# [-d]使账号无密码。# [-f]强迫用户下次登录时修改密码。</code></pre><h3 id="4-2Linux系统用户组的管理"><a href="#4-2Linux系统用户组的管理" class="headerlink" title="4.2Linux系统用户组的管理"></a>4.2Linux系统用户组的管理</h3><h4 id="4-2-1增加一个新的用户组"><a href="#4-2-1增加一个新的用户组" class="headerlink" title="4.2.1增加一个新的用户组"></a>4.2.1增加一个新的用户组</h4><pre><code class="lang-shell">groupadd [-g GID] username# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-2删除一个已有的用户组"><a href="#4-2-2删除一个已有的用户组" class="headerlink" title="4.2.2删除一个已有的用户组"></a>4.2.2删除一个已有的用户组</h4><pre><code class="lang-shell">groupdel groupname</code></pre><h4 id="4-2-3修改用户组的属性"><a href="#4-2-3修改用户组的属性" class="headerlink" title="4.2.3修改用户组的属性"></a>4.2.3修改用户组的属性</h4><pre><code class="lang-shell">groupmod [-g GID] groupname# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-4更改用户组"><a href="#4-2-4更改用户组" class="headerlink" title="4.2.4更改用户组"></a>4.2.4更改用户组</h4><p><strong>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。</strong></p><pre><code class="lang-shell">newgrp root</code></pre><h3 id="4-3Linux文件用户属性修改"><a href="#4-3Linux文件用户属性修改" class="headerlink" title="4.3Linux文件用户属性修改"></a>4.3Linux文件用户属性修改</h3><pre><code class="lang-shell">chown [-R] user_name filename_OR_dirname  # 更改文件或目录的所有者chgrp [-R] group_name filename_OR_dirname  # 更改文件或目录所在组# [-R]参数递归更改目录下所有文件的用户属性</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">http://man.linuxde.net/tar</a></p><p>2.<a href="https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html" target="_blank" rel="noopener">https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html</a></p><p>3.<a href="https://www.cnblogs.com/52php/p/5677628.html" target="_blank" rel="noopener">https://www.cnblogs.com/52php/p/5677628.html</a></p><p>4.<a href="https://www.jb51.net/LINUXjishu/43356.html" target="_blank" rel="noopener">https://www.jb51.net/LINUXjishu/43356.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML图介绍</title>
      <link href="/2019/UML%E5%9B%BE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/UML%E5%9B%BE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用例视图"><a href="#1-用例视图" class="headerlink" title="1.用例视图"></a>1.用例视图</h2><h2 id="1-1用例图"><a href="#1-1用例图" class="headerlink" title="1.1用例图"></a>1.1用例图</h2><p>描述角色以及角色与用例之间的连接关系。说明的是谁要使用系统，以及他们使用该系统可以做些什么。</p><h2 id="2设计视图"><a href="#2设计视图" class="headerlink" title="2设计视图"></a>2设计视图</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p>根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p><p>类图是描述系统中的类，以及各个类之间的关系的静态视图。能够让我们在正确编写代码以前对系统有一个全面的认识。类图是一种模型类型，确切的说，是一种静态模型类型。</p><h3 id="2-2对象图"><a href="#2-2对象图" class="headerlink" title="2.2对象图"></a>2.2对象图</h3><p>描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。</p><p>与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。</p><h2 id="3-进程视图"><a href="#3-进程视图" class="headerlink" title="3.进程视图"></a>3.进程视图</h2><h3 id="3-1序列图（顺序图）"><a href="#3-1序列图（顺序图）" class="headerlink" title="3.1序列图（顺序图）"></a>3.1序列图（顺序图）</h3><p>交互图的一种，描述了对象之间消息发送的先后顺序，强调时间顺序。</p><p>序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。</p><h3 id="3-2协作图"><a href="#3-2协作图" class="headerlink" title="3.2协作图"></a>3.2协作图</h3><p>交互图的一种，描述了收发消息的对象的组织关系，强调对象之间的合作关系。时序图按照时间顺序布图，而写作图按照空间结构布图</p><p>和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择协作图；这两种图合称为交互图。</p><h3 id="3-3状态图"><a href="#3-3状态图" class="headerlink" title="3.3状态图"></a>3.3状态图</h3><p>是一种由状态、变迁、事件和活动组成的状态机，用来描述类的对象所有可能的状态以及时间发生时状态的转移条件。</p><p>描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。状态图是对类图的补充。</p><h3 id="3-4活动图"><a href="#3-4活动图" class="headerlink" title="3.4活动图"></a>3.4活动图</h3><p>是状态图的一种特殊情况，这些状态大都处于活动状态。本质是一种流程图，它描述了活动到活动的控制流。</p><p>描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能</p><h2 id="4-实现视图"><a href="#4-实现视图" class="headerlink" title="4.实现视图"></a>4.实现视图</h2><h3 id="4-1构件图-（组件图）"><a href="#4-1构件图-（组件图）" class="headerlink" title="4.1构件图 （组件图）"></a>4.1构件图 （组件图）</h3><p>描述代码构件的物理结构以及各种构建之间的依赖关系。用来建模软件的组件及其相互之间的关系，这些图由构件标记符和构件之间的关系构成。在组件图中，构件时软件单个组成部分，它可以是一个文件，产品、可执行文件和脚本等。</p><h2 id="5-拓扑视图"><a href="#5-拓扑视图" class="headerlink" title="5.拓扑视图"></a>5.拓扑视图</h2><h3 id="5-1部署图"><a href="#5-1部署图" class="headerlink" title="5.1部署图"></a>5.1部署图</h3><p>是用来建模系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。部署图的使用者是开发人员、系统集成人员和测试人员。</p><h2 id="6-软件设计及过程"><a href="#6-软件设计及过程" class="headerlink" title="6.软件设计及过程"></a>6.软件设计及过程</h2><p>在需求阶段：采用用例图来描述需求<br>在分析阶段：采用类图来描述静态结构<br>在设计阶段：采用类图、包图对类的接口进行设计<br>在实现阶段：将类用某个面向对象的语言实现<br>在集成与交付阶段：构件图、包图、部署图<br>在测试阶段：单元测试使用类图和类的规格说明书<br>                     集成测试阶段使用类图、包图、构件图和合作图<br>                     系统测试使用用例图来测试系统功能</p>]]></content>
      
      
      <categories>
          
          <category> 知识介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 软件设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边缘计算系统中延迟敏感任务的成本有效调度</title>
      <link href="/2019/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BB%B6%E8%BF%9F%E6%95%8F%E6%84%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%88%90%E6%9C%AC%E6%9C%89%E6%95%88%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BB%B6%E8%BF%9F%E6%95%8F%E6%84%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%88%90%E6%9C%AC%E6%9C%89%E6%95%88%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>边缘计算作为一种新兴的计算模型，可以将具有有限计算资源和能量的物联网（IoT）设备的延迟敏感计算任务卸载到边缘云。在边缘计算系统中，多个服务器放置在IoT设备附近的网络边缘上以处理卸载的任务。边缘计算系统的一个关键问题是如何在完成卸载任务的同时降低系统成本。在本文中，我们研究任务调度问题，以降低边缘计算系统的成本。我们将任务调度问题建模为优化问题，其目标是在满足所有任务的延迟要求的同时最小化系统成本。然后，我们证明了所提出的优化问题是NP难的。为了有效地解决这个优化问题，我们提出了一种任务调度算法，称为两阶段任务调度成本优化（TTSCO）。我们通过与最优解进行比较来验证算法的有效性。结果表明，对于我们使用的95％的数据集，近似比率小于1.2。性能评估表明，该算法能够有效降低边缘计算系统的成本，同时满足所有任务的延迟要求。索引术语 - 边缘计算;任务调度;延迟敏感的任务;成本效益;</p><h3 id="云计算与边缘计算的区别和边缘计算要解决的问题"><a href="#云计算与边缘计算的区别和边缘计算要解决的问题" class="headerlink" title="云计算与边缘计算的区别和边缘计算要解决的问题"></a>云计算与边缘计算的区别和边缘计算要解决的问题</h3><p>随着物联网技术的发展，延迟敏感应用（例如，健康监测[1]，基于位置的增强现实游戏）的数量正在迅速增加[2]。由于物联网设备的计算资源和能量有限，因此应将许多处理繁重的任务卸载到远程服务器进行处理。具有强大计算能力的云计算被认为是处理卸载任务的潜在方式。但是，由于传统云和物联网设备之间的距离较远，将大量任务发送到传统云进行处理会导致响应时间过长，网络拥塞严重。为了解决这个问题，最近提出边缘计算作为一种有前景的计算模型[3]，[4]。边缘计算提供附加的计算基础设施层，其由网络边缘处的一些服务器（即，基站）组成。对于从物联网设备卸载的计算任务，边缘计算提供计算服务并将结果返回给设备。这样，卸载任务的传输延迟和核心网的流量负载将大大降低。</p><h3 id="在边缘计算中的任务调度问题"><a href="#在边缘计算中的任务调度问题" class="headerlink" title="在边缘计算中的任务调度问题"></a>在边缘计算中的任务调度问题</h3><p>设备如何进行任务卸载决策<br>降低传输或计算任务所产生的系统成本<br>边缘计算系统中任务调度问题的成本优化<br>在边缘计算中，任务调度问题已成为研究的热门话题[9] - [18]。为了减少由任务计算引起的能耗，物联网设备会将计算任务卸载到边缘服务器。但是，卸载任务会消耗额外的能量来将任务传输到边缘服务器，卸载任务的完成时间也会增加。在这种情况下，一些工作研究了设备如何进行任务卸载决策[9] - [12]。另外，当计算任务被调度到不同的边缘服务器时，传输和计算的成本也不同。因此，一些工作旨在降低传输或计算任务所产生的系统成本[13] - [18]。但是，这些工作很少考虑边缘服务器生成的成本。在非高峰时间（例如，在夜间）降低由服务器引起的系统成本的问题在很大程度上未被探索[5]。</p><h3 id="本文研究的问题"><a href="#本文研究的问题" class="headerlink" title="本文研究的问题"></a>本文研究的问题</h3><p>边缘计算系统中任务调度问题的成本优化<br>在本文中，我们研究边缘计算系统中任务调度问题的成本优化。目标是在满足所有任务的QoS要求的同时最小化边缘计算系统的成本。我们为延迟敏感的输入任务开发了一个任务调度模型。然后，我们制定成本优化问题并证明该优化问题为NP-Hard。接下来，我们提出了一种近似算法来解决这个优化问题，称为两阶段任务调度成本优化（TTSCO），并对TTSCO算法进行分析。最后，仿真结果验证了算法的准确性和性能。</p><p>边缘计算作为一种新兴的计算模型，可以将具有有限计算资源和能量的物联网（IoT）设备的延迟敏感计算任务卸载到边缘云。在边缘计算系统中，多个服务器放置在IoT设备附近的网络边缘上以处理卸载的任务。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边缘计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解的使用</title>
      <link href="/2019/java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-三种标准注解"><a href="#1-三种标准注解" class="headerlink" title="1.三种标准注解"></a>1.三种标准注解</h3><ul><li><p>@Override,表示当前的方法定义覆盖了父类中的方法。必须要有相同的方法签名即(方法名，参数类型，参数顺序，参数个数)都一样。否则在编译过程中发出错误提示。</p></li><li><p>@Deprecated,对不应该再使用的方法添加注解，当使用这个方法的时候，会在编译时候显示提示信息。</p></li><li><p>@SuppressWarnings,关闭不当的编译器报警信息</p></li></ul><h3 id="2-四种元注解："><a href="#2-四种元注解：" class="headerlink" title="2.四种元注解："></a>2.四种元注解：</h3><ul><li><p>@Target,表示该注解可以用什么地方。如CONSTRUCTOR,构造器声明；FIELD,域声明;METHOD,方法声明;TYPE，类，接口或enum声明</p></li><li><p>@Retention,表示需要在什么级别保存该注解信息。如SOURCE,注解将被编译器丢弃；CLASS,注解在class文件可用，但会被VM丢弃RUNTIME,VM将在运行期间也保留注解，可以使用反射机制读取注解信息</p></li><li><p>@Documented,将此注解包含到Javadoc中。</p></li><li><p>@Inherited,允许子类继承父类的注解。</p></li></ul><p>Java 7开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生</li><li><p>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</p></li><li><p>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化开源项目</title>
      <link href="/2019/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-D3"><a href="#1-D3" class="headerlink" title="1.D3"></a>1.<a href="https://d3js.org/" target="_blank" rel="noopener">D3</a></h3><p>github地址:<a href="https://github.com/d3/d3" target="_blank" rel="noopener">https://github.com/d3/d3</a></p><p><img src="/images/2019/8_10_d3.png" alt="d3"></p><h3 id="2-chartjs"><a href="#2-chartjs" class="headerlink" title="2.chartjs"></a>2.<a href="https://www.chartjs.org" target="_blank" rel="noopener">chartjs</a></h3><p>github地址:<a href="https://github.com/chartjs/Chart.js" target="_blank" rel="noopener">https://github.com/chartjs/Chart.js</a></p><p><img src="/images/2019/8_10_charts.png" alt="Screenshot_20190810_184821"></p><h3 id="3-leafletjs"><a href="#3-leafletjs" class="headerlink" title="3.leafletjs"></a>3.<a href="https://leafletjs.com/examples.html" target="_blank" rel="noopener">leafletjs</a></h3><p>github地址:<a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="noopener">https://github.com/Leaflet/Leaflet</a></p><p>主要是移动到地图的支持</p><p><img src="/images/2019/8_10_leafletjs.png" alt="Screenshot_20190810_185124"></p><h3 id="4-echarts"><a href="#4-echarts" class="headerlink" title="4.echarts"></a>4.<a href="https://echarts.baidu.com/examples/#chart-type-line" target="_blank" rel="noopener">echarts</a></h3><p>百度家的</p><p>github地址:<a href="https://github.com/ecomfe/echarts" target="_blank" rel="noopener">https://github.com/ecomfe/echarts</a></p><p><img src="/images/2019/8_10_echarts.png" alt="Screenshot_20190810_185457"></p><h3 id="5-Chartist-js"><a href="#5-Chartist-js" class="headerlink" title="5.Chartist-js"></a>5.<a href="https://gionkunz.github.io/chartist-js/examples.html" target="_blank" rel="noopener">Chartist-js</a></h3><h3 id="6-sigmajs"><a href="#6-sigmajs" class="headerlink" title="6.sigmajs"></a>6.<a href="http://sigmajs.org/" target="_blank" rel="noopener">sigmajs</a></h3><h3 id="7-metricsgraphicsjs"><a href="#7-metricsgraphicsjs" class="headerlink" title="7.metricsgraphicsjs"></a>7.<a href="https://metricsgraphicsjs.org/examples.htm" target="_blank" rel="noopener">metricsgraphicsjs</a></h3><h3 id="8-DC-js-开源-D3"><a href="#8-DC-js-开源-D3" class="headerlink" title="8.DC.js,开源(D3)"></a>8.<a href="https://dc-js.github.io/dc.js/" target="_blank" rel="noopener">DC.js,开源(D3)</a></h3><h3 id="9-阿里数据可视化"><a href="#9-阿里数据可视化" class="headerlink" title="9.阿里数据可视化"></a>9.<a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">阿里数据可视化</a></h3><p><a href="https://antv.alipay.com/zh-cn/g2/3.x/demo/index.html" target="_blank" rel="noopener">G2</a>,<a href="https://antv.alipay.com/zh-cn/g6/2.x/demo/index.html" target="_blank" rel="noopener">G6</a>,<a href="https://antv.alipay.com/zh-cn/f2/3.x/demo/index.html" target="_blank" rel="noopener">F2</a>,<a href="https://antv.alipay.com/zh-cn/l7/1.x/demo/index.html" target="_blank" rel="noopener">L7</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的iptables配置过程</title>
      <link href="/2018/%E7%AE%80%E5%8D%95%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/%E7%AE%80%E5%8D%95%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>简单的记一下iptables的配置过程，以后用到了就不用再google了<br>总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则</p><h2 id="iptables配置过程"><a href="#iptables配置过程" class="headerlink" title="iptables配置过程"></a>iptables配置过程</h2><h3 id="1-清除规则"><a href="#1-清除规则" class="headerlink" title="1.清除规则:"></a>1.清除规则:</h3><p>清楚旧的规则<br>iptables -F 清除预设表filter中的所有规则链的规则<br>iptables -X 清除预设表filter中使用者自定链中的规则</p><h3 id="2-设定预设规则"><a href="#2-设定预设规则" class="headerlink" title="2.设定预设规则"></a>2.设定预设规则</h3><p>默认情况下对各种包的处理方式<br>iptables -p INPUT DROP<br>iptables -p OUTPUT ACCEPT<br>iptables -p FORWARD DROP</p><h3 id="3-添加用户自定义规则"><a href="#3-添加用户自定义规则" class="headerlink" title="3.添加用户自定义规则"></a>3.添加用户自定义规则</h3><p>对于特定端口协议的包的规则进行设置<br>iptables -A INPUT -p tcp —dport 22 -j ACCEPT<br>-A:表示添加规则到INPUT(OUTPUT,FORWARD)链<br>-p:表示tcp(udp)协议<br>—dport(—sport):目的端口号(源端口号)<br>-j():添加规则为接受</p><h3 id="4-保存规则"><a href="#4-保存规则" class="headerlink" title="4.保存规则"></a>4.保存规则</h3><p>不保存的话重启后就没有了<br>service iptables save</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html" target="_blank" rel="noopener">http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket网络编程</title>
      <link href="/2018/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h3><pre><code class="lang-c">int inet_aton(const char *cp, struct in_addr *inp);</code></pre><p>转换网络主机地址为二进制数值并存储与第二个参数中<br>函数返回0表示主机地址无效，非0表示主机地址有效<br>转化完后需要调用htons或htonl函数才能将主机字节序转换为网络字节序用于网络传输</p><pre><code class="lang-c">char *inet_ntoa(struct in_addr in);</code></pre><p>转换网络字节序为标准的ASCII以点分开的地址，函数返回字符串指针<br>该字符串空间为静态分配，第二次调用时会覆盖第一次的内容</p><pre><code class="lang-c">in_addr_t inet_addr(const char *cp);</code></pre><p>转换网络主机地址为网络字节序二进制值<br>参数无效，返回-1(INADDR_NONE)<br>注意：转换255.255.255.255时也返回-1</p><pre><code class="lang-c">int inet_pton(int af, const char *src, void *dst);</code></pre><p>转换字符串到网络地址，af是地址簇，<em>src是来源地址，</em> dst接收转换后的数据。</p><pre><code class="lang-c">const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);</code></pre><p>转换网络字节序二进制值到ASCII类型的地址，参数的作用和inet_pton相同，<br>socklen_t cnt指所指向缓存区dst的大小，避免溢出，如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。</p><pre><code class="lang-c">int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);</code></pre><p>int maxfdp 指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。<br>struct fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄。监视这些文件描述符的读变化</p><pre><code class="lang-c">int setsockopt(SOCKET s,int level,int optname,const char* optval,int optlen);</code></pre><p>s(套接字): 指向一个打开的套接口描述字<br>level:(级别)： 指定选项代码的类型。<br>SOL_SOCKET: 基本套接口<br>IPPROTO_IP: IPv4套接口<br>IPPROTO_IPV6: IPv6套接口<br>IPPROTO_TCP: TCP套接口<br>optname(选项名)： 选项名称<br>optval(选项值): 是一个指向变量的指针 类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }<br>optlen(选项长度) ：optval 的大小</p><pre><code class="lang-c">int PASCAL FAR recvfrom( SOCKET s, char FAR* buf, int len, int flags,struct sockaddr FAR* from, int FAR* fromlen);</code></pre><p>s：标识一个已连接套接口的描述字。<br>buf：接收数据缓冲区。<br>len：缓冲区长度。<br>flags：调用操作方式。<br>from：（可选）指针，指向装有源地址的缓冲区。<br>fromlen：（可选）指针，指向from缓冲区长度值。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://blog.csdn.net/zyy617532750/article/details/58595700" target="_blank" rel="noopener">https://blog.csdn.net/zyy617532750/article/details/58595700</a><br>2.<a href="https://www.cnblogs.com/zhoudingcocng/p/6209961.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoudingcocng/p/6209961.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机基础知识</title>
      <link href="/2018/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识</p><h2 id="1-集合及其运算"><a href="#1-集合及其运算" class="headerlink" title="1.集合及其运算"></a>1.集合及其运算</h2><h3 id="1-1子集和真子集"><a href="#1-1子集和真子集" class="headerlink" title="1.1子集和真子集"></a>1.1子集和真子集</h3><p>$A$子集：$A \subseteq B​$或$B \subseteq A​$<br>$A​$是$B​$的真子集：$A \subset B​$或$B \subset A​$<br>$x​$是$A​$的一个元素：$x \in A​$<br>$x​$不是$A​$的一个元素：$x \notin A​$</p><h3 id="1-2集合的交并差补"><a href="#1-2集合的交并差补" class="headerlink" title="1.2集合的交并差补"></a>1.2集合的交并差补</h3><p>$A$和$B$的并集：$A\cup B={x|x\in A或x\in B}$<br>$A$和$B$的交集：$A\cap B={x|x\in A且x\in B}$<br>$A$和$B$的差集：$A - B={x|x\in A且x\notin B}$<br>若$B\subseteq A$我们也称$A−B$为$B$的（关于$A$）补,记作：$\overline B(A)​$</p><h3 id="1-3集合的并的推广"><a href="#1-3集合的并的推广" class="headerlink" title="1.3集合的并的推广"></a>1.3集合的并的推广</h3><p>设$I​$是某些标号的集合我们将$\displaystyle \bigcup_{i\in I}A_i={x|存在i\in I,使得x\in A_i}​$</p><h3 id="1-4A的幂集"><a href="#1-4A的幂集" class="headerlink" title="1.4A的幂集"></a>1.4A的幂集</h3><p>$A$的所有子集的集合，记作$2^A={B|B\subseteq A}​$</p><h3 id="1-5笛卡尔乘积"><a href="#1-5笛卡尔乘积" class="headerlink" title="1.5笛卡尔乘积"></a>1.5笛卡尔乘积</h3><p>$A\times B={(a,b)|a\in A且b\in B}$</p><h3 id="1-6集合之间的关系"><a href="#1-6集合之间的关系" class="headerlink" title="1.6集合之间的关系"></a>1.6集合之间的关系</h3><p>由$A$到$B$的关系是$A×B$的任何子集。若$A=B$，则称为$A$上的关系。若$R$为$A$到$B$的关系，当$(a,b)$在$R$内时，可写成$aRb​$</p><h3 id="1-7集合关系的性质"><a href="#1-7集合关系的性质" class="headerlink" title="1.7集合关系的性质"></a>1.7集合关系的性质</h3><p>设$R$是集合$A$上的关系，则有<br>（1）若对$A$中的任一元素$a$，都有$aRa$，则称$R$是<strong>自反的</strong>；<br>（2）若对$A$中的任何元素$a,b$，从$aRb$能够推到出$bRa$，则称$R$是<strong>对称的</strong>；<br>（3）若$a,b,c$是$A$中的元素，从$aRb$和$bRc$能够推出$aRc$，则称$R$是<strong>传递的</strong>；<br>若关系$R​$同时是自反的，对称的和传递的，则称之为<strong>等价关系</strong>。<br>2018-09-22 15:28:12</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.《形式语言与自动机》陈有祺编著</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度旋度和散度</title>
      <link href="/2018/%E6%A2%AF%E5%BA%A6%E6%97%8B%E5%BA%A6%E5%92%8C%E6%95%A3%E5%BA%A6/"/>
      <url>/2018/%E6%A2%AF%E5%BA%A6%E6%97%8B%E5%BA%A6%E5%92%8C%E6%95%A3%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>有关梯度旋度和散度的定义和计算,记录一下</p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><h3 id="1-1梯度"><a href="#1-1梯度" class="headerlink" title="1.1梯度"></a>1.1梯度</h3><p>设函数$u=f(x,y,z)$在空间区域\(G\)内具有一阶连续偏导数,其中点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">\left\{  \frac {\partial f}{\partial x},  \frac {\partial f}{\partial y},  \frac {\partial f}{\partial z}\right\}=\frac {\partial f}{\partial x}\vec i+\frac {\partial f}{\partial y}\vec j+\frac {\partial f}{\partial z}\vec k</script><p>为函数$u=f(x,y,z)$在点$P(x,y,z)​$的<strong>梯度</strong><br>记为$gradf(x,y,z)​$或$\nabla f(x,y,z)$</p><p>(注:</p><script type="math/tex; mode=display">\nabla = \frac {\partial}{\partial x}\vec i+\frac {\partial}{\partial y}\vec j+\frac {\partial}{\partial z}\vec k</script><p>称为三维的向量微分算子)</p><h3 id="1-2旋度"><a href="#1-2旋度" class="headerlink" title="1.2旋度"></a>1.2旋度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}​$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">  \begin{vmatrix}  \vec i & \vec j & \vec k \\  \frac {\partial}{\partial x} & \frac {\partial}{\partial y} & \frac {\partial}{\partial z} \\  v_x & v_y & v_z \\  \end{vmatrix} =   (\frac {\partial v_z}{\partial y} - \frac {\partial v_y}{\partial z})\vec i+  (\frac {\partial v_x}{\partial z} - \frac {\partial v_z}{\partial x})\vec j+  (\frac {\partial v_y}{\partial x} - \frac {\partial v_x}{\partial y})\vec k</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>旋度</strong><br>记为$curl\;v$或者$\nabla \times v$</p><h3 id="1-3散度"><a href="#1-3散度" class="headerlink" title="1.3散度"></a>1.3散度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G​$</p><p>标量</p><script type="math/tex; mode=display">\frac {\partial v_x}{\partial x}+\frac {\partial v_y}{\partial y}+\frac {\partial v_z}{\partial z}</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>散度</strong><br>记为$div\;v$或者$\nabla \cdot v​$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度 </tag>
            
            <tag> 旋度 </tag>
            
            <tag> 散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim的使用</title>
      <link href="/2018/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h3><p>h,j,k,l(空格):向左，下，上，右移动光标</p><p>Ctrl+(f,b,d,u):屏幕向下移一页，向上移一页，向下移半页，向上移半页<br>+-:下一行，上一行<br>H,M,L:光标移动到这个屏幕的最上方，中央，最下方那一行的第一个字符<br>G,nG,gg:移动都文档末，移动到第n行，移动到第一行<br>n:向下移动n行</p><h3 id="2-搜索替换"><a href="#2-搜索替换" class="headerlink" title="2.搜索替换"></a>2.搜索替换</h3><p>/word:向光标之下寻找word<br>?word:向光标之上寻找word<br>n,N:重复搜索（不变方向，改变方向）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-vim.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中关于路径的知识</title>
      <link href="/2018/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-python">os.getcwd()#输出当前路径os.listdir()#输出当前路径下的所有文件夹名和文件名os.remove(&#39;filename.xxx&#39;)和os.unlink(&#39;filename.xxx&#39;)功能一样#删除文件filename.xxxos.rmdir(&#39;path&#39;)#删除目录（目录必须为空）os.removedirs(&#39;p1//p2//p3&#39;)#依次删除目录p3,p2,p1直到某一目录不为空os.chdir(&#39;path&#39;)#更改当前路径</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://www.cnblogs.com/yanglang/p/7610838.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/7610838.html</a><br>2.<a href="https://blog.csdn.net/muwinter/article/details/77196261" target="_blank" rel="noopener">https://blog.csdn.net/muwinter/article/details/77196261</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python类和实例的一些属性</title>
      <link href="/2018/python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-self和-init"><a href="#1-self和-init" class="headerlink" title="1.self和__init__()"></a>1.self和__init__()</h2><p>self代表类的实例,如下：</p><pre><code class="lang-python">class Test:    a,b=&#39;classa&#39;,&#39;classb&#39;#类的属性    def __init__(self):        self.b=&#39;selfb&#39;#实例的属性        self.c=&#39;selfc&#39;print(Test.a)print(Test.b)#-output:classa classb-访问类的属性a=Test()print(a.a)#-output:classa-通过实例访问类的属性print(a.b)#-output:selfb-当实例和类都具有某属性时,输出实例属性print(a.c)print(Test.c)#output</code></pre><p>当实例和类有相同的属性时，如何通过实例访问类的属性呢？<br>可以通过__class__访问</p><h2 id="2-class"><a href="#2-class" class="headerlink" title="2.__class__"></a>2.__class__</h2><p>__class__是指实例所对应的类</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test:    a=&#39;classa&#39;    print(count)    def __init__(self):        self.a=&#39;selfa&#39;        print(self)        #-output:&lt;__main__.Test object at 0x055A1270&gt;        print(self.__class__)        #-output:&lt;class &#39;__main__.Test&#39;&gt;a=Test()print(&#39;实例a&#39;,a)#-output:&lt;__main__.Test object at 0x055A1270&gt;print(&#39;类Test&#39;,Test)#-output:&lt;class &#39;__main__.Test&#39;&gt;print(a.a,a.__class__.a)#-output:selfa classa</code></pre><p>通过__init__()可以实现对类的实例的统计</p><pre><code># -*- coding: utf-8 -*-class Test(object):    count=0    def __init__(self):        super(Test, self).__init__()        self.__class__.count+=1if __name__==&quot;__main__&quot;:    a=Test()    print(Test.count)    b=Test()    print(Test.count)    Test()    print(Test.count)</code></pre><p>输出为</p><pre><code>123</code></pre><p>每创建一个Test类的实例,Test.count都加1</p><h2 id="3-dict"><a href="#3-dict" class="headerlink" title="3.__dict__"></a>3.__dict__</h2><p>__dict__是一个字典，键是属性名，值为属性值。<br>类有自己的__dict__，类的实例也有自己的__dict__</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test(object):    classa=&#39;classa&#39;    def __init__(self):        super(Test, self).__init__()        self.selfb=&#39;selfb&#39;if __name__==&quot;__main__&quot;:    print(Test.__dict__)    a=Test()    print(a.__dict__)</code></pre><p>输出为</p><pre><code class="lang-shell">{&#39;__module__&#39;: &#39;__main__&#39;, &#39;classa&#39;: &#39;classa&#39;, &#39;__init__&#39;: &lt;function Test.__init__ at 0x04D03468&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Test&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Test&#39; objects&gt;, &#39;__doc__&#39;: None}{&#39;selfb&#39;: &#39;selfb&#39;}</code></pre><p>可见类Test有classa属性以及一些其他属性<br>类Test的实例a只有self.b属性</p><h2 id="4-len-self-函数"><a href="#4-len-self-函数" class="headerlink" title="4.__len__(self)函数"></a>4.__len__(self)函数</h2><p>返回元素个数，实现len()方法。即类实现了__len__()函数就可以使用len()函数</p><h2 id="5-getitem-self-key"><a href="#5-getitem-self-key" class="headerlink" title="5.__getitem__(self,key)"></a>5.__getitem__(self,key)</h2><p>实现字典一样的功能，当类的实例对象（假设为P）调用P[key]时，调用此函数返回。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1,<a href="https://docs.python.org/" target="_blank" rel="noopener">https://docs.python.org</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python3之模块</title>
      <link href="/2018/python3%E4%B9%8B%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/python3%E4%B9%8B%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-python3模块"><a href="#1-python3模块" class="headerlink" title="1.python3模块"></a>1.python3模块</h2><p>简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，变量，也可以包含可执行代码。</p><h2 id="2-模块的引入"><a href="#2-模块的引入" class="headerlink" title="2.模块的引入"></a>2.模块的引入</h2><h3 id="2-1import引入"><a href="#2-1import引入" class="headerlink" title="2.1import引入"></a>2.1import引入</h3><pre><code>import module1,[module2[,.........moduleN]]</code></pre><p>一个模块只会被导入一次，不管执行了多少次import，这样可以防止导入模块被重复执行。</p><h3 id="2-2from-import语句"><a href="#2-2from-import语句" class="headerlink" title="2.2from * import语句"></a>2.2from * import语句</h3><pre><code>from modname import name1,name2..........nameNfrom mod import func_1</code></pre><p>这个声明不会把整个mod模块导入到当前命名空间中，它只会将mod里的func_1单个引入到执行这个声明的模块的全局符号表。</p><p>from … import * ：这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。</p><h2 id="3-搜索路径"><a href="#3-搜索路径" class="headerlink" title="3.搜索路径"></a>3.搜索路径</h2><p>搜索顺序：当前目录-&gt;系统环境变量PATHONHOME-&gt;标准链接库目录<br>通过<code>sys.path</code>可查看搜索路径</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#39;&#39;, &#39;C:\\Python36\\python36.zip&#39;, &#39;C:\\Python36\\DLLs&#39;, &#39;C:\\Python36\\lib&#39;, &#39;C:\\Python36&#39;, &#39;C:\\Python36\\lib\\site-packages&#39;]</code></pre><h2 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4.命名空间"></a>4.命名空间</h2><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称（键）和它们各自相应的对象们（值）的字典。<br>函数内用到全局变量要用global语句，否则会当作局部变量处理</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题:"></a>其他问题:</h2><p>1.python模块里的可执行代码何时执行？<br>当导入模块时，python顶层的代码会执行一次，若要重新执行模块的顶层代码需要通道reload()函数<br>另外python3中的reload()需要从imp包中导入<br>2.关于python模块循环引入的问题？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.cnblogs.com/zhangxinqi/p/7905103.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxinqi/p/7905103.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DEBUG常用功能</title>
      <link href="/2018/DEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/DEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>window 10中DEBUG的安装,以及DEBUG调试中一些常用的命令</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>window 10中好像已经没有了Debug的调试工具，需要下载另外的软件</p><p>下载安装DOSBox.百度云下载地址：(DOSBOX)[<a href="https://pan.baidu.com/s/1cC3cuy" target="_blank" rel="noopener">https://pan.baidu.com/s/1cC3cuy</a>]<br>下载后先安装DOSBox0.74-win32-installer.exe<br>然后找到文件dos-box0.74.conf(C:\Users\username\AppData\Local\DOSBox)<br>添加两行  </p><pre><code class="lang-bat">MOUNT C E:\DEBUG                  # 将目录E:\DEBUG挂载为DOSBOX下的C:  set PATH=$PATH$;E:\DEBUG          # 将E:\DEBUG写入环境变量PATH中</code></pre><p>并将下载的MASM.exe,LINK.exe,debug.exe三个文件放入目录E:\DEBUG<br>打开软件，输入<code>c:</code>就可以使用debug命令了  </p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令:"></a>2.常用命令:</h3><p>R命令：查看改变CPU寄存器的内容<br>D命令：查看内存中的内容<br>E命令：改写内存中的内容<br>U命令：将内存中的机器指令翻译成汇编指令<br>T命令：执行一条机器指令<br>A命令：以汇编指令的格式在内存中写入一条机器指令<br>Q命令：退出DEBUG调试  </p><h3 id="3-命令具体使用实例"><a href="#3-命令具体使用实例" class="headerlink" title="3.命令具体使用实例"></a>3.命令具体使用实例</h3><h4 id="3-1R命令"><a href="#3-1R命令" class="headerlink" title="3.1R命令:"></a>3.1R命令:</h4><p>R命令：查看改变CPU寄存器的内容  </p><pre><code class="lang-bat">-r                          ;显示寄存器的值-r reg                      ;改变寄存器reg的值</code></pre><p><img src="/images/2018/2_12_R命令.PNG" alt="img"></p><h3 id="3-2D命令"><a href="#3-2D命令" class="headerlink" title="3.2D命令:"></a>3.2D命令:</h3><p>D命令：查看内存中的内容<br>默认显示128字节的内容  </p><pre><code class="lang-bat">-d                          ;默认地址-d 段地址:偏移地址            ;指定地址-d 段地址:偏一偏二            ;两个地址间的内容</code></pre><p><img src="/images/2018/2_12_D命令.PNG" alt="img"></p><h3 id="3-3E命令"><a href="#3-3E命令" class="headerlink" title="3.3E命令:"></a>3.3E命令:</h3><p>E命令：改写内存中的内容  </p><pre><code class="lang-bat">-e 起始地址 数据 数据 ...   -e 起始地址</code></pre><p><img src="/images/2018/2_12_E命令.PNG" alt="img"></p><h3 id="3-4U命令"><a href="#3-4U命令" class="headerlink" title="3.4U命令:"></a>3.4U命令:</h3><p>U命令：将内存中的机器指令翻译成汇编指令<br>与D命令有些类似<br><img src="/images/2018/2_12_U命令.PNG" alt="img"></p><h3 id="3-5T命令"><a href="#3-5T命令" class="headerlink" title="3.5T命令:"></a>3.5T命令:</h3><p>T命令：执行内存中的一条机器指令<br>指令位置由cs:ip确定<br><img src="/images/2018/2_12_T命令.PNG" alt="img"></p><h3 id="3-6A命令"><a href="#3-6A命令" class="headerlink" title="3.6A命令:"></a>3.6A命令:</h3><p>A命令：以汇编指令的格式在内存中写入一条机器指令<br><img src="/images/2018/2_12_A命令.PNG" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DEBUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用中的一些问题</title>
      <link href="/2018/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2018/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-配置问题"><a href="#1-配置问题" class="headerlink" title="1.配置问题"></a>1.配置问题</h3><p>全局配置</p><pre><code class="lang-shell">$ git config --list  查看当前用户信息$ git config --global user.name &quot;username&quot; 配置用户名$ git config --global user.email emailname@example.com 配置邮箱</code></pre><p>项目配置(进入项目目录)</p><pre><code class="lang-shell">$ cat .git/config  项目配置信息$ git config  user.name &quot;username&quot; 配置用户名$ git config  user.email emailname@example.com 配置邮箱</code></pre><p>全局的配置就是加上—global<br>项目未设置的配置默认使用全局配置</p><h3 id="2-密钥问题"><a href="#2-密钥问题" class="headerlink" title="2.密钥问题"></a>2.密钥问题</h3><pre><code>$ cd ~/.ssh  查看是否存在密钥$ ssh-keygen -t rsa -C &quot;emailname@example.com&quot; 生成密钥$ ssh -T git@github.com  测试是否配置成功</code></pre><p>生成密钥过程中回车三次，是密码为空，不然每次push都要输入密码<br>生成密钥后主要有两个文件<br>~/.ssh/id_rsa<br>私钥进行处理后的一些内容<br>~/.ssh/id_rsa.pub<br>公钥进行处理后的内容，提交到服务器(github或coding)的内容<br>~/.ssh/known_hosts<br>这个文件可能会有，是ssh对服务器的一些记录</p><h3 id="3-工作区、暂存区和版本库"><a href="#3-工作区、暂存区和版本库" class="headerlink" title="3.工作区、暂存区和版本库"></a>3.工作区、暂存区和版本库</h3><p><img src="/images/2019/5_19_git.jpg" alt="img"></p><p><code>git add</code>：暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p><p><code>git commit</code>：暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p><p><code>git reset HEAD</code> ：暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p><p><code>git rm --cached &lt;file&gt;</code>：直接从暂存区删除文件，工作区则不做出改变。</p><p><code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code>：用暂存区全部或指定的文件替换工作区的文件。<strong>这个操作很危险，会清除工作区中未添加到暂存区的改动。</strong></p><p><code>git checkout HEAD .</code>或者 <code>git checkout HEAD &lt;file&gt;</code>：用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。<strong>这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单了解汇编</title>
      <link href="/2018/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96/"/>
      <url>/2018/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-汇编是什么"><a href="#1-汇编是什么" class="headerlink" title="1.汇编是什么"></a>1.汇编是什么</h3><p>汇编语言的主体是汇编指令，汇编指令是由机器指令发展而来，例如：<br>操作：将寄存器bx的内容送到ax<br>机器指令：101100000000000000000011<br>记起来太过于复杂，从而有了替代它的<br>汇编指令：<code>mov ax,bx</code><br>方便记忆，也符合人们的逻辑思维<br>程序员们编写汇编指令，在通过编译器编译成机器指令，然后就可以在计算机中运行了（如今的大部分高级语言是通过编译器，将高级语言转换成汇编语言，在编译成机器语言在电脑中运行）<br>不管什么语言，都要转换成机器语言在电脑中运行，汇编语言和高级语言都是人们为了简化程序制作过程而已  </p><h3 id="2-计算机的总线"><a href="#2-计算机的总线" class="headerlink" title="2.计算机的总线"></a>2.计算机的总线</h3><p>从逻辑上总线分为三类（8086）<br>数据总线：传送数据，总线宽度决定一次读取数据多少（16）<br>地址总线：指定地址，总线宽度决定寻址能力（20）<br>控制总线：控制读写  </p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>RAM：程序和数据都要加载到RAM即内存中，才能通过CPU运行，可读可写<br>ROM：一些芯片的主要参数，及操作指令，芯片出厂时已经固定，仅可读<br>计算机运行时，全部程序和数据都要加载到RAM中<br>通过ROM中的一些必要信息，CPU才能对外设进行操作  </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> x8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python遇到的错误</title>
      <link href="/2017/python%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2017/python%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>python使用在中遇到的错误</p><h3 id="1-DLL-load-failed"><a href="#1-DLL-load-failed" class="headerlink" title="1.DLL load failed"></a>1.DLL load failed</h3><p><font color="red">python ImportError: DLL load failed: %1 不是有效的 Win32 应用程序</font><br>解决方法：去下载与你所安装的Python版本对应的pywin32并安装<br>下载链接：<a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a><br>对应版本和位数<br>Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:42:59) [MSC v.1500 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.<br>还有一种可能是导入的模块是64位的，而你的python是32位的  </p><h3 id="2-使用libsvm-for-python时出错-1"><a href="#2-使用libsvm-for-python时出错-1" class="headerlink" title="2.使用libsvm for python时出错[1]"></a>2.使用libsvm for python时出错[1]</h3><pre><code class="lang-shell">Traceback (most recent call last):  File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 28, in &lt;module&gt;    libsvm = CDLL(path.join(dirname, r&#39;..\windows\libsvm.dll&#39;))  File &quot;C:\Python36\lib\ctypes\__init__.py&quot;, line 348, in __init__    self._handle = _dlopen(self._name, mode)OSError: [WinError 126] 找不到指定的模块。During handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;train.py&quot;, line 3, in &lt;module&gt;    from libsvm.python.svmutil import *  File &quot;C:\Python36\lib\libsvm\python\svmutil.py&quot;, line 5, in &lt;module&gt;    from svm import *  File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 38, in &lt;module&gt;    raise Exception(&#39;LIBSVM library not found.&#39;)Exception: LIBSVM library not found.</code></pre><p>出错原因：在github上下载的libsvm中的libsvm.lib是win64版本的，而自己的python版本是32位的<br>解决方案：<br>方法1.更换python版本（太麻烦了，还要重新下载好多库）<br>方法2.去<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">万能宝库</a>上下载对应版本的.whl文件，（不用安装）直接解压后找到<a href="https://download.lfd.uci.edu/pythonlibs/o4uhg4xd/libsvm-3.22-cp27-cp27m-win32.whl" target="_blank" rel="noopener">libsvm.lib</a>更换即可<br>2018-09-07 22:11:58</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://blog.csdn.net/rena521/article/details/51187981" target="_blank" rel="noopener">https://blog.csdn.net/rena521/article/details/51187981</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libsvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算的妙用之二进制1的个数</title>
      <link href="/2017/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2017/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求出一个正整数转换成二进制形式中数字”1”的个数<br>题目：求出一个正整数转换成二进制形式中数字”1”的个数<br>如：<br>int 型数值为 80<br>转化成二进制形式：80 = 00000000 00000000 00000000 01010000<br>因此 1 的个数为 2  </p><h3 id="0-普通解法"><a href="#0-普通解法" class="headerlink" title="0.普通解法"></a>0.普通解法</h3><p>一位一位判断</p><pre><code class="lang-c">int bitCount1(int n) {    int count = 0;    while (n != 0) {        if (n &amp; 0x01 == 1)            count++;        n = n &gt;&gt; 1;    }    return count;}</code></pre><h3 id="2-大神的解法"><a href="#2-大神的解法" class="headerlink" title="2.大神的解法"></a>2.大神的解法</h3><pre><code class="lang-c">int bitCount2(int n) {    n = n - ((n &gt;&gt; 1) &amp; 0x55555555);//n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333);    n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f);    n = n + (n &gt;&gt; 8);               //n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff);    n = n + (n &gt;&gt; 16);              //n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff);    return n &amp; 0x0000003f;          //return n;}</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1.<a href="https://www.jianshu.com/p/25c75149e7a2" target="_blank" rel="noopener">https://www.jianshu.com/p/25c75149e7a2</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件读写</title>
      <link href="/2017/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2017/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>C语言文件操作笔记</p><pre><code class="lang-c">FILE *fopen(char *filename,char *type); //打开文件int fclose(FILE *stream); //关闭文件int fgetc(FILE *stream); //读一个字符指针后移int getc(FILE *stream);int fputc(int ch,FILE *stream); //写一个字符指针后移int putc(int ch,FILE *stream);</code></pre><p>filename指明文件路径<br>type可取的至如下<br>“r” :打开一个已有的文本文，允许读取文件<br>“w” :打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容<br>“a” :打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。<br>“r+”:打开一个文本文件，允许读写文件<br>“w+”:打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件<br>“a+”:打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式<br>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式:<br><code>&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime_Text3插入当前时间</title>
      <link href="/2017/sublime_Text3%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/"/>
      <url>/2017/sublime_Text3%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>sublime_Text3插入当前时间</p><h3 id="1-创建新snippet"><a href="#1-创建新snippet" class="headerlink" title="1.创建新snippet"></a>1.创建新snippet</h3><p>tool → new snippet 创建一个新的snippet,并保存为”author.sublime-snippet”(最好在该目录(User)下再创建一个MySnippet目录):<br>其内容:  </p><pre><code class="lang-xml">&lt;snippet&gt;&lt;content&gt;&lt;![CDATA[/** * ============================ * @Author:   XX * @Version:  1.0  * @DateTime: ${1:alt+t} * ============================ */]]&gt;&lt;/content&gt;    &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;    &lt;tabTrigger&gt;author&lt;/tabTrigger&gt;    &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;    &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt;</code></pre><h3 id="2-创建新插件"><a href="#2-创建新插件" class="headerlink" title="2.创建新插件"></a>2.创建新插件</h3><p>Tools → New Plugin. 创建时间插件,保存在User目录,命名为addCurrentTime.py:<br>其内容为:  </p><pre><code class="lang-python">import sublime, sublime_pluginimport datetimeclass AddCurrentTimeCommand(sublime_plugin.TextCommand):    def run(self, edit):        self.view.run_command(&quot;insert_snippet&quot;,             {                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)             }        )</code></pre><h3 id="3-绑定快捷键"><a href="#3-绑定快捷键" class="headerlink" title="3.绑定快捷键"></a>3.绑定快捷键</h3><p>Preference → Key Bindings → User.绑定快捷键:  </p><pre><code>[    {        &quot;command&quot;: &quot;add_current_time&quot;,        &quot;keys&quot;: [            &quot;alt+t&quot;        ]    }]</code></pre><p>其中绑定的命令的名字是由所创建的插件的类名而来<br>AddCurrentTimeCommand—&gt;add_current_time<br>这应该是Sublime创建插件的规则  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1,<a href="http://www.cnblogs.com/xiaomingzaixian/p/6984664.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaomingzaixian/p/6984664.html</a><br>2,<a href="http://blog.csdn.net/sshfl_csdn/article/details/46415551" target="_blank" rel="noopener">http://blog.csdn.net/sshfl_csdn/article/details/46415551</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配</title>
      <link href="/2017/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2017/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>从左到右依次比较<br>s:主串<br>r:模式串  </p><pre><code class="lang-c">int BM(char *s,int slen,char *r,int rlen){    int i=1,j=1;    while(i&lt;=slen-rlen+1){        while(j&lt;=rlen&amp;&amp;s[i]==r[j]){            i++;j++;        }        if(j&gt;rlen){            return i-j+1;        }else{            j=1;i++;        }    }    return 0;}</code></pre><h1 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h1><p>通过一个next数字<br>当每次发生不匹配的时候<br>模式串不必回到开头  </p><pre><code class="lang-c">int* getnext(char *r, int n) { //next数组求解    int i, j;    int *next = (int *)malloc((n + 1) * sizeof(int));    next[0] = n; next[1] = 0;    j = 0;    i=1;    while(i&lt;n){        if (j == 0 || r[i] == r[j]) {            ++i; ++j;            next[i] = j;        } else {            j = next[j];        }    }    return next;}int KMP(char *s,int slen,char *r,int rlen){    int *next=getnext(r,rlen);    int i=1,j=1;    while(i&lt;=slen&amp;&amp;j&lt;=rlen){        while(j&lt;=rlen&amp;&amp;s[i]==r[j]){            i++;j++;        }        if(j&gt;rlen){            return i-j+1;        }else{            j=next[j];i++;        }    }    return 0;}</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片头文件解析</title>
      <link href="/2017/%E5%9B%BE%E7%89%87%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/%E5%9B%BE%E7%89%87%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>各种类型的图片头文件解析</p><h3 id="1-PNG图片文件头"><a href="#1-PNG图片文件头" class="headerlink" title="1.PNG图片文件头"></a>1.PNG图片文件头</h3><h4 id="1-1PNG文件结构"><a href="#1-1PNG文件结构" class="headerlink" title="1.1PNG文件结构"></a>1.1PNG文件结构</h4><p>PNG图像格式文件由一个8字节的PNG文件标识（file signature）域和3个以上的后续数据块（IHDR、IDAT、IEND等）组成。<br>PNG文件包括8字节文件署名（89 50 4E 47 0D 0A 1A 0A，十六进制），用来识别PNG格式。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">十六进制</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">89</td><td style="text-align:left">用于检测传输系统是否支持8位的字符编码（8 bit data），用以减少将文本文件被错误的识别成PNG文件的机会，反之亦然。</td></tr><tr><td style="text-align:center">50 4E 47</td><td style="text-align:left">PNG每个字母对应的ASCII，让用户可以使用文本编辑器查看时，识别出是PNG文件。</td></tr><tr><td style="text-align:center">0D 0A</td><td style="text-align:left">DOS风格的换行符（CRLF）。用于DOS-Unix数据的换行符转换。</td></tr><tr><td style="text-align:center">1A</td><td style="text-align:left">在DOS命令行下，用于阻止文件显示的文件结束符。</td></tr><tr><td style="text-align:center">0A</td><td style="text-align:left">Unix风格的换行符（LF）。用于Unix-DOS换行符的转换。</td></tr></tbody></table></div><h3 id="1-2PNG数据块（chunk）"><a href="#1-2PNG数据块（chunk）" class="headerlink" title="1.2PNG数据块（chunk）"></a>1.2PNG数据块（chunk）</h3><p>PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。<br>关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也都必须要支持这些数据块。虽然PNG文件规范没有要求PNG编译码器对可选数据块进行编码和译码，但规范提倡支持可选数据块。<br>下表就是PNG中数据块的类别，其中，关键数据块部分我们使用红色背景加以区分。</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据块符号</th><th style="text-align:center">数据块名称</th><th style="text-align:center">多数据块</th><th style="text-align:center">可选否</th><th style="text-align:center">位置限制</th></tr></thead><tbody><tr><td style="text-align:center">IHDR</td><td style="text-align:center">文件头数据块</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">第一块</td></tr><tr><td style="text-align:center">cHRM</td><td style="text-align:center">基色和白色点数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE和IDAT之前</td></tr><tr><td style="text-align:center">gAMA</td><td style="text-align:center">图像γ数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE和IDAT之前</td></tr><tr><td style="text-align:center">sBIT</td><td style="text-align:center">样本有效位数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE和IDAT之前</td></tr><tr><td style="text-align:center">PLTE</td><td style="text-align:center">调色板数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在IDAT之前</td></tr><tr><td style="text-align:center">bKGD</td><td style="text-align:center">背景颜色数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE之后IDAT之前</td></tr><tr><td style="text-align:center">hIST</td><td style="text-align:center">图像直方图数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE之后IDAT之前</td></tr><tr><td style="text-align:center">tRNS</td><td style="text-align:center">图像透明数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在PLTE之后IDAT之前</td></tr><tr><td style="text-align:center">oFFs</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在IDAT之前</td></tr><tr><td style="text-align:center">pHYs</td><td style="text-align:center">物理像素尺寸数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在IDAT之前</td></tr><tr><td style="text-align:center">sCAL</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">在IDAT之前</td></tr><tr><td style="text-align:center">IDAT</td><td style="text-align:center">图像数据块</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">与其他IDAT连续</td></tr><tr><td style="text-align:center">tIME</td><td style="text-align:center">图像最后修改时间数据块</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">tEXt</td><td style="text-align:center">文本信息数据块</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">zTXt</td><td style="text-align:center">压缩文本数据块</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">fRAc</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">gIFg</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">gIFt</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">gIFx</td><td style="text-align:center">(专用公共数据块)</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">IEND</td><td style="text-align:center">图像结束数据</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">最后一个数据块</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 文件解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件头 </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS自带python26升级到27</title>
      <link href="/2017/CentOS%E8%87%AA%E5%B8%A6python26%E5%8D%87%E7%BA%A7%E5%88%B027/"/>
      <url>/2017/CentOS%E8%87%AA%E5%B8%A6python26%E5%8D%87%E7%BA%A7%E5%88%B027/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h3><pre><code class="lang-sh">#下载wget http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2#解压并更改目录   tar -jxvf Python-2.7.3.tar.bz2cd Python-2.7.3#编译安装./configuremake allmake installmake cleanmake distclean</code></pre><p>安装需要gcc(如果系统没有gcc需要自己安装)</p><pre><code class="lang-sh">yum install -y gcc</code></pre><p>查看版本信息</p><pre><code>[root@host ~]# /usr/local/bin/python2.7 -VPython 2.7.3[root@host ~]# python -VPython 2.6.6</code></pre><p>python2.7已经安装,但系统的python还是2.6</p><h3 id="2-建立软连接"><a href="#2-建立软连接" class="headerlink" title="2.建立软连接"></a>2.建立软连接</h3><p>使系统默认的python指向python2.7  </p><pre><code class="lang-sh">rm /usr/bin/python /usr/bin/python2.6ln -s /usr/local/bin/python2.7 /usr/bin/python</code></pre><p>但yum命令依赖python2.6.6，需要更改一些配置文件  </p><pre><code class="lang-sh">su root                         ##切换到root  vi /usr/bin/yum                 ##打开文件</code></pre><p><del>/usr/bin/python</del> ##删除此行<br>/usr/bin/python2.6.6 ##改为此行<br>更改需要管理员权限  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://blog.csdn.net/jcjc918/article/details/11022345" target="_blank" rel="noopener">http://blog.csdn.net/jcjc918/article/details/11022345</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现简单TCP通信</title>
      <link href="/2017/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95TCP%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95TCP%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>C实现简单TCP通信</p><h3 id="1-添加所需的window库"><a href="#1-添加所需的window库" class="headerlink" title="1.添加所需的window库"></a>1.添加所需的window库</h3><p>在VC6++下编程<br>代码用到了其他的lib库,需要添加<br>工程—&gt;设置—&gt;Link—&gt;library modules添加ws2_32.lib(与其他lib用空格隔开)</p><h3 id="2-服务器端代码"><a href="#2-服务器端代码" class="headerlink" title="2.服务器端代码:"></a>2.服务器端代码:</h3><pre><code class="lang-c">#include&quot;winsock2.h&quot;#include &quot;stdio.h&quot;#define SERVER_PORP 8884//服务器端口号void main(){    //加载套接字（winsock）库，    //加载这段代码拷贝于MSDN中WSAStartup的介绍    WORD wVersionRequested;    WSADATA wsaData;    int err;    wVersionRequested = MAKEWORD( 1, 1 );     //版本号为1.1    err = WSAStartup( wVersionRequested, &amp;wsaData );    if ( err != 0 ) {        return;    }    if ( LOBYTE( wsaData.wVersion ) != 1 ||    HIBYTE( wsaData.wVersion ) != 1 ) {        WSACleanup( );        return;    }    //创建套接字    SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0);    //AF_INET指协议簇    //SOCK_STREAM参数设置为TCP连接    SOCKADDR_IN addrServer;     //设置服务器端套接字的相关属性    addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY);     //设置IP    addrServer.sin_family=AF_INET;    addrServer.sin_port=htons(SERVER_PORP);     //设置端口号    //将套接字绑定到本地地址和指定端口上    bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR));    //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废    listen(sockServer,5);    SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口    int len=sizeof(SOCKADDR);    while(1) //不断监听    {        //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求        SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len);        if(sockConn!=INVALID_SOCKET) //创建成功        {            char sendInfo[100];            //inet_ntoa将结构转换为十进制的IP地址字符串            sprintf(sendInfo,&quot;welcome %s to this Server!&quot;,inet_ntoa(addrClient.sin_addr));            //成功建立连接后向客户端发送数据，结果将显示在客户端上            send(sockConn,sendInfo,strlen(sendInfo)+1,0);            //从客户端接收数据，结果显示在服务器上            char recvInfo[100];            recv(sockConn,recvInfo,100,0);            printf(&quot;%s\n&quot;,recvInfo);            while(1)            {                if(recv(sockConn,recvInfo,100,0)&lt;0)                    break;                  //客户端断开recv返回负值                printf(&quot;%s\n&quot;,recvInfo);                sprintf(sendInfo,recvInfo);                send(sockConn,sendInfo,strlen(sendInfo)+1,0);                sprintf(sendInfo,&quot;\nsever receive this text!\n&quot;);                send(sockConn,sendInfo,strlen(sendInfo)+1,0);            }            //将本次建立连接中得到套接字关闭            closesocket(sockConn);        }        else        {            int errCode=WSAGetLastError();            printf(&quot;the errcode is:%d\n&quot;,errCode);        }    }    //如果本程序不是死循环，那么在此处还应添加以下代码：    closesocket(sockServer); //对一直处于监听状态的套接字进行关闭    WSACleanup(); //终止对winsocket库的使用}</code></pre><h3 id="3-客户端代码"><a href="#3-客户端代码" class="headerlink" title="3.客户端代码:"></a>3.客户端代码:</h3><pre><code class="lang-c">#include &quot;winsock2.h&quot;#include &quot;stdio.h&quot;#define SERVER_IP   &quot;127.0.0.1&quot; //服务器IP地址#define SERVER_PORP 8884        //服务器端口号void main(){    //加载套接字库    WORD wVersionRequested;    WSADATA wsaData;    int err;    wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1    err = WSAStartup( wVersionRequested, &amp;wsaData );    if ( err != 0 ) {        return;    }    if ( LOBYTE( wsaData.wVersion ) != 1 ||    HIBYTE( wsaData.wVersion ) != 1 ) {        WSACleanup( );        return;    }    SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接    SOCKADDR_IN addrServer; //服务器地址结构    addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址    addrServer.sin_port=htons(SERVER_PORP); //服务器端口号    addrServer.sin_family=AF_INET;    //与服务器端建立连接，进行通信    int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR));    if(connReult!=WSAEADDRNOTAVAIL) //访问成功    {        //成功建立连接后向服务器端发送数据，结果将显示在服务器端上        char sendInfo[100];        send(sockClient,&quot;this is zhangsan!&quot;,strlen(&quot;this is zhangsan!&quot;)+1,0);        //接收来自服务器端发送来的信息        char recvInfo[100];        recv(sockClient,recvInfo,100,0);        printf(&quot;%s\n&quot;,recvInfo);        while(1)        {            scanf(&quot;%s&quot;,sendInfo);            send(sockClient,sendInfo,strlen(sendInfo)+1,0);            recv(sockClient,recvInfo,100,0);            printf(&quot;%s&quot;,recvInfo);            recv(sockClient,recvInfo,100,0);            printf(&quot;%s&quot;,recvInfo);        }    }    else    {        int errCode=WSAGetLastError();        printf(&quot;the errcode is:%d\n&quot;,errCode);    }    closesocket(sockClient);    WSACleanup();}</code></pre><p>客户端和服务器应分别属于两个exe<br>先运行服务器，后运行客户端  </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> TCP </tag>
            
            <tag> 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VC6聊天室程序设计</title>
      <link href="/2017/VC6%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/VC6%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>了解了C语言多线程的实例和简单的TCP通信，来编写一个简单的聊天室<br>曾经java实现的聊天室程序在这里</p><h3 id="1-客户端程序"><a href="#1-客户端程序" class="headerlink" title="1.客户端程序"></a>1.客户端程序</h3><p>客户端需要两个线程，主线程接受用户输入并发送到服务器<br>另一个线程监听服务器发来的消息，显示在屏幕上  </p><pre><code class="lang-c">#include &quot;winsock2.h&quot;#include &quot;stdio.h&quot;#define SERVER_IP   &quot;10.80.167.248&quot;#define SERVER_PORP 8884//blog:vhcffh.com//author:FreyDWORD WINAPI ThreadFun(LPVOID pM)  {       SOCKET sockClient=*(SOCKET *)pM;    char recvInfo[100];    while(1)    {        if(recv(sockClient,recvInfo,100,0)&gt;0)        {            printf(&quot;%s&quot;,recvInfo);        }    }    return 0;}void main(){    //加载套接字库    WORD wVersionRequested;    WSADATA wsaData;    int err;    wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1    err = WSAStartup( wVersionRequested, &amp;wsaData );    if ( err != 0 ) {        return;    }    if ( LOBYTE( wsaData.wVersion ) != 1 ||    HIBYTE( wsaData.wVersion ) != 1 ) {        WSACleanup( );        return;    }    SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接    SOCKADDR_IN addrServer; //服务器地址结构    addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址    addrServer.sin_port=htons(SERVER_PORP); //服务器端口号    addrServer.sin_family=AF_INET;    //与服务器端建立连接，进行通信    char name[100];    printf(&quot;请输入姓名:&quot;);    scanf(&quot;%s&quot;,name);    int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR));    if(connReult!=WSAEADDRNOTAVAIL) //访问成功    {        CreateThread(NULL, 0, ThreadFun, (void *)&amp;sockClient, 0, NULL);         printf(&quot;连接成功\n&quot;);        //成功建立连接后向服务器端发送数据，结果将显示在服务器端上        char sendInfo[100];        sprintf(sendInfo,name);        send(sockClient,sendInfo,strlen(sendInfo)+1,0);        //接收来自服务器端发送来的信息        //char recvInfo[100];        //recv(sockClient,recvInfo,100,0);        //printf(&quot;%s\n&quot;,recvInfo);        while(1)        {            scanf(&quot;%s&quot;,sendInfo);            send(sockClient,sendInfo,strlen(sendInfo)+1,0);        }    }    else    {        int errCode=WSAGetLastError();        printf(&quot;the errcode is:%d\n&quot;,errCode);    }    closesocket(sockClient);    WSACleanup();}</code></pre><h3 id="2-服务器程序"><a href="#2-服务器程序" class="headerlink" title="2.服务器程序"></a>2.服务器程序</h3><p>用一个链表来存储用户的套接字和姓名<br>主线程监听用户的连接，每当有新用户连接，将其信息加入链表，并传入第二个线程<br>第二个线程接受客户端发来的信息，并将信息传入第三个线程<br>第三个线程从链表中读取用户套接字，将接到的信息转发给所有在线用户  </p><pre><code class="lang-c">#include &quot;winsock2.h&quot;#include &quot;stdio.h&quot;#include &lt;windows.h&gt;//blog:zfblog.xyz//author:Frey#define SERVER_PORP 8884struct client_info{    SOCKET sockConn;    char name[100];    client_info *next;};//存放每一个用户的信息client_info * C_info_head;DWORD WINAPI Threadmes(LPVOID pM){    char sendInfo[100];    sprintf(sendInfo,(char *)pM);    for(int i=0;i&lt;=c_info_num;i++){        SOCKET sockConn=C_info[i].sockConn;        //if(C_info[i].num!=-1){        send(sockConn,sendInfo,strlen(sendInfo)+1,0);        //}    }    return 0;}//将某条消息群发给所有客户端void sendmessage(char *message){    CreateThread(NULL, 0, Threadmes, (void *)message, 0, NULL);}//接收每个用户的信息DWORD WINAPI ThreadFun(LPVOID pM)  {       client_info c_info = *(client_info *)pM;    SOCKET sockConn=c_info.sockConn;    char sendInfo[100];    //inet_ntoa将结构转换为十进制的IP地址字符串    //sprintf(sendInfo,&quot;welcome %s to this Server!&quot;,inet_ntoa(addrClient.sin_addr));    //成功建立连接后向客户端发送数据，结果将显示在客户端上    //send(sockConn,sendInfo,strlen(sendInfo)+1,0);    //从客户端接收数据，结果显示在服务器上    char recvInfo[100];    recv(sockConn,recvInfo,100,0);    sprintf(c_info.name,recvInfo);    printf(&quot;欢迎%s进入聊天室\n&quot;,recvInfo);    sprintf(sendInfo,&quot;欢迎%s进入聊天室\n&quot;,recvInfo);    sendmessage(sendInfo);    while(1)    {           if(recv(sockConn,recvInfo,100,0)&lt;0)            break;        printf(&quot;[%s]:%s\n&quot;,c_info.name,recvInfo);        sprintf(sendInfo,&quot;[%s]:%s\n&quot;,c_info.name,recvInfo);        sendmessage(sendInfo);    }    //将本次建立连接中得到套接字关闭    closesocket(sockConn);    return 0;}void main(){    //加载套接字（winsock）库，加载这段代码拷贝于MSDN中WSAStartup的介绍    WORD wVersionRequested;    WSADATA wsaData;    int err;    wVersionRequested = MAKEWORD( 1, 1 ); //版本号为1.1    err = WSAStartup( wVersionRequested, &amp;wsaData );    if ( err != 0 ) {        return;    }    if ( LOBYTE( wsaData.wVersion ) != 1 ||    HIBYTE( wsaData.wVersion ) != 1 ) {        WSACleanup( );        return;    }    //消息存储及发送    //----------------------------------------------------    //创建套接字    SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接    SOCKADDR_IN addrServer; //设置服务器端套接字的相关属性    addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY); //设置IP    addrServer.sin_family=AF_INET;    addrServer.sin_port=htons(SERVER_PORP); //设置端口号    //将套接字绑定到本地地址和指定端口上    bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR));    //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废    listen(sockServer,5);    SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口    int len=sizeof(SOCKADDR);    while(1) //不断监听    {        //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求        SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len);        if(sockConn!=INVALID_SOCKET) //创建成功        {               c_info_num++;            C_info[c_info_num].num=c_info_num;            C_info[c_info_num].sockConn=sockConn;            CreateThread(NULL, 0, ThreadFun, (void *)&amp;C_info[c_info_num], 0, NULL);         }        else        {            int errCode=WSAGetLastError();            printf(&quot;the errcode is:%d\n&quot;,errCode);        }    }    //如果本程序不是死循环，那么在此处还应添加以下代码：    closesocket(sockServer); //对一直处于监听状态的套接字进行关闭    WSACleanup(); //终止对winsocket库的使用}</code></pre><p><font color="red">未完成的问题</font><br>用户离线时出现bug<br>全部代码:<a href="https://github.com/summerIwinter/Chatroom" target="_blank" rel="noopener">https://github.com/summerIwinter/Chatroom</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> C语言 </tag>
            
            <tag> 聊天室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言多线程学习</title>
      <link href="/2017/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>VC6++环境下C语言创建多线程</p><h3 id="1-简单的创建多线程实例"><a href="#1-简单的创建多线程实例" class="headerlink" title="1.简单的创建多线程实例"></a>1.简单的创建多线程实例</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//子线程函数DWORD WINAPI ThreadFun(LPVOID pM){    printf(&quot;子线程的线程ID号为：%d\n子线程输出 Hello World\n&quot;, GetCurrentThreadId());    return 0;}//主函数，所谓主函数其实就是主线程执行的函数。int main(){    printf(&quot;最简单的创建多线程实例\n&quot;);    printf(&quot;http://zfblog.xyz&quot;);    HANDLE handle = CreateThread(NULL, 0, ThreadFun, NULL, 0, NULL);    WaitForSingleObject(handle, INFINITE);    return 0;}</code></pre><p>使用CreateThread函数创建线程</p><pre><code class="lang-c">HANDLE  WINAPI   CreateThread(           LPSECURITY_ATTRIBUTES   lpThreadAttributes,           DWORD    dwStackSize,           LPTHREAD_START_ROUTINE    lpStartAddress,           LPVOID    lpParameter,           DWORD   dwCreationFlags,           LPDWORD   lpThreadId);</code></pre><p>第一个参数表示线程内核对象的安全属性,一般传入NULL表示使用默认设置<br>第二个参数表示线程栈空间大小,传入0表示使用默认大小(1MB)<br>第三个参数表示新线程所执行的线程函数地址<br>　　　　　　　多个线程可以使用同一个函数地址(线程函数入口)<br>第四个参数是传给线程函数的参数<br>第五个参数指定额外的标志来控制线程的创建<br>　　　　　　　就是控制线程何时运行<br>　　　　　　　为0:直接运行<br>　　　　　　　为CREATE_SUSPENDED:调用ResumeThread()后运行<br>第六个参数将返回线程的ID号,传入NULL表示不需要返回该线程ID号<br>函数返回值:成功返回新线程的句柄,失败返回NULL  </p><h3 id="2-关于CreateThread-给线程函数传递参数的问题"><a href="#2-关于CreateThread-给线程函数传递参数的问题" class="headerlink" title="2.关于CreateThread()给线程函数传递参数的问题"></a>2.关于CreateThread()给线程函数传递参数的问题</h3><pre><code class="lang-c">//创建线程时传递参数int *parameter;CreateThread(NULL, 0, ThreadFun, (void *)parameter, 0, NULL);//想到一个问题直接使用全局的static变量会出现什么情况?????//parameter是任意类型的地址//线程函数中调用参数DWORD WINAPI ThreadFun(LPVOID pM){        //传入的地址指向一个int类型的数据        int p=*PM;        return 0;}</code></pre><p>WaitForSingleObject函数作用</p><pre><code class="lang-c">DWORD  WINAPI  WaitForSingleObject(        HANDLE   hHandle,        DWORD   dwMilliseconds);</code></pre><p>第一个参数为要等待的内核对象<br>第二个参数为最长等待的时间<br>　　　　　　为5000:等待5秒<br>　　　　　　为0:立即执行<br>　　　　　　为INFINITE:无限等待<br>函数返回值:WAIT_OBJECT_0在指定的时间内对象被触发<br>　　　　　　WAIT_TIMEOUT超过最长等待时间对象仍未被触发<br>　　　　　　WAIT_FAILED传入参数有错误<br>函数作用<br>首先要知道—-线程的句柄在线程运行时是未触发的，结束后触发<br>在主函数中调用等待线程执行完毕，然后主函数结束<br>不用此函数可能会导致线程没有执行完，主函数结束，程序结束  </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows系统盘瘦身</title>
      <link href="/2017/windows%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%98%A6%E8%BA%AB/"/>
      <url>/2017/windows%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%98%A6%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>C盘满了，瘦一下身</p><h3 id="1-关闭系统休眠功能"><a href="#1-关闭系统休眠功能" class="headerlink" title="1.关闭系统休眠功能"></a>1.关闭系统休眠功能</h3><p>删除Hiberfil.sys文件<br>管理员运行cmd输入下面命令<br><code>powercfg -h of</code></p><h3 id="2-设置虚拟内存"><a href="#2-设置虚拟内存" class="headerlink" title="2.设置虚拟内存"></a>2.设置虚拟内存</h3><p>控制面板—&gt;(系统和安全)—&gt;系统—&gt;高级系统设置—&gt;(高级)—&gt;设置—&gt;(高级)—&gt;更改<br>把虚拟内存设置到其它盘  </p><h3 id="3-删除临时文件"><a href="#3-删除临时文件" class="headerlink" title="3.删除临时文件"></a>3.删除临时文件</h3><p>以下三个目录里的文件是临时文件，可以删除<br>C:\windows\temp<br>C:\ProgramData\TEMP<br>C:\Users\你的用户名\AppData\Local\Temp  </p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统瘦身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>powershell卸载自带应用</title>
      <link href="/2017/powershell%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/"/>
      <url>/2017/powershell%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>通过powershell卸载windows自带应用</p><h3 id="1-卸载全部自带应用"><a href="#1-卸载全部自带应用" class="headerlink" title="1.卸载全部自带应用"></a>1.卸载全部自带应用</h3><p><code>Get-AppxPackage -User $env:USERNAME | Remove-AppxPackage</code>  </p><h3 id="2-其他更多卸载"><a href="#2-其他更多卸载" class="headerlink" title="2.其他更多卸载"></a>2.其他更多卸载</h3><p>OneNote:<br><code>Get-AppxPackage OneNote | Remove-AppxPackage</code><br>3D:<br><code>Get-AppxPackage 3d | Remove-AppxPackage</code><br>Camera相机:<br><code>Get-AppxPackage camera | Remove-AppxPackage</code><br>邮件和日历:<br><code>Get-AppxPackage communi | Remove-AppxPackage</code><br>新闻订阅:<br><code>Get-AppxPackage bing | Remove-AppxPackage</code><br>Groove音乐电影与电视:<br><code>Get-AppxPackage zune | Remove-AppxPackage</code><br>人脉:<br><code>Get-AppxPackage people | Remove-AppxPackage</code><br>手机伴侣Phone Companion:<br><code>Get-AppxPackage phone | Remove-AppxPackage</code><br>照片:<br><code>Get-AppxPackage photo | Remove-AppxPackage</code><br>纸牌游戏(还敢要钱的那货):<br><code>Get-AppxPackage solit | Remove-AppxPackage</code><br>录音机:<br><code>Get-AppxPackage soundrec | Remove-AppxPackage</code><br>Xbox:<br><code>Get-AppxPackage xbox | Remove-AppxPackage</code>  </p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windwos </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>powershell脚本遍历目录</title>
      <link href="/2017/powershell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/"/>
      <url>/2017/powershell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>powershell脚本遍历目录</p><h3 id="1-遍历目录及子目录-显示目录大小"><a href="#1-遍历目录及子目录-显示目录大小" class="headerlink" title="1.遍历目录及子目录,显示目录大小"></a>1.遍历目录及子目录,显示目录大小</h3><pre><code class="lang-sh">function filesize ([string]$filepath) {    if ($filepath -eq $null) {        throw &quot;路径不能为空&quot;    }    dir -Path $filepath | ForEach-Object -Process {        if ($_.psiscontainer -eq $true) {            $length = 0            dir -Path $_.fullname -Recurse | ForEach-Object {                $length += $_.Length            }            $l = $length / 1KB            $_.name + &quot;文件夹的大小为: {0:n1} KB&quot; -f $l        }    }}filesize -filepath &quot;D:\&quot;</code></pre><h3 id="2-运行示例"><a href="#2-运行示例" class="headerlink" title="2.运行示例:"></a>2.运行示例:</h3><pre><code>PS F:\python&gt; function filesize ([string]$filepath) {&gt;&gt; if ($filepath -eq $null) {&gt;&gt; throw &quot;路径不能为空&quot;&gt;&gt; }&gt;&gt; dir -Path $filepath | ForEach-Object -Process {&gt;&gt; if ($_.psiscontainer -eq $true) {&gt;&gt; $length = 0&gt;&gt; dir -Path $_.fullname -Recurse | ForEach-Object {&gt;&gt; $length += $_.Length&gt;&gt; }&gt;&gt; $l = $length / 1KB&gt;&gt; $_.name + &quot;文件夹的大小为: {0:n1} KB&quot; -f $l&gt;&gt; }&gt;&gt; }&gt;&gt; }PS F:\python&gt; filesize -filepath &quot;f:\python&quot;ipluyou文件夹的大小为: 82,196.5 KBloginip_jlu文件夹的大小为: 16.8 KB嗅事百科文件夹的大小为: 4.3 KB小说文件夹的大小为: 31,043.6 KB笑料文件夹的大小为: 1,578,575.8 KBPS F:\python&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windwos </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己写一个Android照相机应用-2</title>
      <link href="/2017/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-2/"/>
      <url>/2017/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-2/</url>
      
        <content type="html"><![CDATA[<p>Android自定义相机的实现<br>首先是要创建camera的生命周期  </p><pre><code class="lang-java">getCamera();//获取Camera对象setStartPreview(Camera camera,SurfaceHolder holder);//预览相机内容releaseCamera();//释放相机资源</code></pre><p>activity生命周期与camera绑定  </p><pre><code class="lang-java">protected void onResume() {    super.onResume();    if (mCamera == null) {        mCamera = getCamera();        if (mHolder != null) {            setStartPreview(mCamera,mHolder);        }    }}protected void onPause() {    super.onPause();    releaseCamera();}</code></pre><p>camera与surfaceview绑定</p><pre><code class="lang-java">//预览图像与camera绑定@Overridepublic void surfaceCreated(SurfaceHolder holder) {    setStartPreview(mCamera,mHolder);}@Overridepublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {    mCamera.stopPreview();    setStartPreview(mCamera,mHolder);}@Overridepublic void surfaceDestroyed(SurfaceHolder holder) {    releaseCamera();}</code></pre><p>声明相机使用权限  </p><pre><code class="lang-xml">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;&lt;/uses-permission&gt;</code></pre><p>实现照相，通过回调将照片数据保存到文件，并将文件路径传递到其它activity(ResultAty)</p><pre><code class="lang-java">private Camera.PictureCallback mPictureCallback = new Camera.PictureCallback() {    @Override    public void onPictureTaken(byte[] data, Camera camera) {//data中存储照片的全部信息        File tempFile = new File(&quot;/sdacrd/temp.png&quot;);        try {            FileOutputStream fos = new FileOutputStream(tempFile);            fos.write(data);            fos.close();            Intent intent = new Intent(CustomCamera.this,ResultAty.class);            intent.putExtra(&quot;picPath&quot;,tempFile.getAbsolutePath());            startActivity(intent);            CustomCamera.this.finish();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }};public void capture(View view){    Camera.Parameters parameters = mCamera.getParameters();    parameters.setPictureFormat(ImageFormat.JPEG);//设置拍照格式jpg格式    parameters.setPictureSize(800,400);//设置照片大小    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//设置自动对焦    mCamera.autoFocus(new Camera.AutoFocusCallback() {  //回调，对焦最清晰时拍照    @Override    public void onAutoFocus(boolean success, Camera camera) {        if (success) {            mCamera.takePicture(null,null,mPictureCallback);        }    }    });}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 相机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA套接字之TCP实现聊天室</title>
      <link href="/2017/JAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
      <url>/2017/JAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<p>java实现聊天室,通过多线程实现随时加入,随时退出</p><h3 id="1-客户端程序"><a href="#1-客户端程序" class="headerlink" title="1.客户端程序"></a>1.客户端程序</h3><p>客户端有两个线程<br>一个线程由主类SocketClient实现向服务器发送消息<br>一个线程由内部类readLineThread实现监听服务器发来的消息并显示  </p><pre><code class="lang-java">import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;public class SocketClient extends Socket{    private static final String SERVER_IP = &quot;127.0.0.1&quot;;    private static final int SERVER_PORT = 2017;    private Socket client;    private PrintWriter out;    private BufferedReader in;    /**     * 与服务器连接，并输入发送消息     */    public SocketClient() throws Exception{        super(SERVER_IP, SERVER_PORT);        client = this;        out = new PrintWriter(this.getOutputStream(), true);        in = new BufferedReader(new InputStreamReader(this.getInputStream()));        new readLineThread();        while(true){            in = new BufferedReader(new InputStreamReader(System.in));            String input = in.readLine();            out.println(input);        }    }    /**     * 用于监听服务器端向客户端发送消息线程类     */    class readLineThread extends Thread{        private BufferedReader buff;        public readLineThread(){            try {                buff = new BufferedReader(new InputStreamReader(client.getInputStream()));                start();            } catch (Exception e) {            }        }        @Override        public void run() {            try {                while(true){                    String result = buff.readLine();                    if(&quot;byeClient&quot;.equals(result)){//客户端申请退出，服务端返回确认退出                        break;                    }else{//输出服务端发送消息                        System.out.println(result);                    }                }                in.close();                out.close();                client.close();            } catch (Exception e) {            }        }    }    public static void main(String[] args) {        try {            new SocketClient();//启动客户端        } catch (Exception e) {        }    }}</code></pre><h3 id="2-服务器程序"><a href="#2-服务器程序" class="headerlink" title="2.服务器程序"></a>2.服务器程序</h3><p>服务器由三个类实现<br>主类Server监听客户端请求，并启用线程处理请求<br>内部类PrintOutThread监听输出消息请求，将消息发送到所有客户端<br>内部类ServerThread提供与每一个用户的连接  </p><pre><code class="lang-java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Server extends ServerSocket {    private static final int SERVER_PORT = 2017;    private static boolean isPrint = false;// 是否输出消息标志    private static List user_list = new ArrayList();// 登录用户集合    private static List&lt;ServerThread&gt; thread_list = new ArrayList&lt;ServerThread&gt;();// 服务器已启用线程集合    private static LinkedList message_list = new LinkedList();// 存放消息队列    /**     * 创建服务端Socket,创建向客户端发送消息线程,监听客户端请求并处理     */    public Server() throws IOException {        super(SERVER_PORT);// 创建ServerSocket        new PrintOutThread();// 创建向客户端发送消息线程        try {            while (true) {// 监听客户端请求，启用一个线程处理                Socket socket = accept();                new ServerThread(socket);            }        } catch (Exception e) {        } finally {            close();        }    }    /**     * 监听是否有输出消息请求线程类,向客户端发送消息     */    class PrintOutThread extends Thread {        public PrintOutThread() {            start();        }        @Override        public void run() {            while (true) {                //没有打印这句，if里面的语句不会执行，可能是多线程访问isPrint造成的                System.out.println(&quot;运行中。。。&quot;+isPrint);                if (isPrint) {// 将缓存在队列中的消息按顺序发送到各客户端,并从队列中清除。                    String message = (String) message_list.getFirst();                    for (ServerThread thread : thread_list) {                        thread.sendMessage(message);                    }                    message_list.removeFirst();                    isPrint = message_list.size() &gt; 0 ? true : false;                }            }        }    }    /**     * 服务器线程类     */    @SuppressWarnings(&quot;unchecked&quot;)    class ServerThread extends Thread {        private Socket client;        private PrintWriter out;        private BufferedReader in;        private String name;        public ServerThread(Socket s) throws IOException {            client = s;            out = new PrintWriter(client.getOutputStream(), true);            in = new BufferedReader(new InputStreamReader(client.getInputStream()));            //in.readLine();            out.println(&quot;成功连上聊天室,请输入你的名字：&quot;);            start();        }        @Override        public void run() {            try {                int flag = 0;                String line = in.readLine();                while (true) {                    // 查看在线用户列表                    if (&quot;showuser&quot;.equals(line)) {                        out.println(this.listOnlineUsers());                    }                    if(&quot;bye&quot;.equals(line)){                        out.println(&quot;bye&quot;);                    break;}                    // 第一次进入，保存名字                    if (flag++ == 0) {                        name = line;                        user_list.add(name);                        thread_list.add(this);                        out.println(name + &quot;你好,可以开始聊天了...&quot;);                        this.pushMessage(&quot;Client&lt;&quot; + name + &quot;&gt;进入聊天室...&quot;);                    } else {                        this.pushMessage(&quot;Client&lt;&quot; + name + &quot;&gt; say : &quot; + line);                    }                    line = in.readLine();                }                out.println(&quot;byeClient&quot;);            } catch (Exception e) {                e.printStackTrace();            } finally {// 用户退出聊天室                try {                    client.close();                } catch (IOException e) {                    e.printStackTrace();                }                thread_list.remove(this);                user_list.remove(name);                pushMessage(&quot;Client&lt;&quot; + name + &quot;&gt;退出了聊天室&quot;);            }        }        // 放入消息队列末尾，准备发送给客户端        private void pushMessage(String msg) {            message_list.addLast(msg);            isPrint = true;        }        // 向客户端发送一条消息        private void sendMessage(String msg) {            out.println(msg);        }        // 统计在线用户列表        private String listOnlineUsers() {            String s = &quot;--- 在线用户列表 ---\015\012&quot;;            for (int i = 0; i &lt; user_list.size(); i++) {                s += &quot;[&quot; + user_list.get(i) + &quot;]\015\012&quot;;            }            s += &quot;--------------------&quot;;            return s;        }    }    public static void main(String[] args) throws IOException {        new Server();// 启动服务端    }}</code></pre><p>这里好像出现了多线程问题</p><pre><code class="lang-java">@Overridepublic void run() {    while (true) {        //没有打印下面这句，if里面的语句不会执行，可能是这个线程一直访问isPrint,改变它的线程不能访问到它造成的        System.out.println(&quot;运行中。。。&quot;+isPrint);        if (isPrint) {// 将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。            String message = (String) message_list.getFirst();            for (ServerThread thread : thread_list) {                thread.sendMessage(message);            }            message_list.removeFirst();            isPrint = message_list.size() &gt; 0 ? true : false;        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> TCP </tag>
            
            <tag> 聊天室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA套接字之TCP简单实用</title>
      <link href="/2017/JAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/"/>
      <url>/2017/JAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>java套接字之TCP</p><h3 id="1-单客户端排队与服务器建立连接"><a href="#1-单客户端排队与服务器建立连接" class="headerlink" title="1.单客户端排队与服务器建立连接"></a>1.单客户端排队与服务器建立连接</h3><p><font color="red">客户端程序</font>  </p><pre><code class="lang-java">import java.net.*;import java.io.*;public class Client{    static Socket server;    public static void main(String[] args)throws Exception{        //客户端请求与本机在5678端口建立TCP连接        server=new Socket(InetAddress.getLocalHost(),5678);        BufferedReader in=            new BufferedReader(new InputStreamReader(server.getInputStream()));        //获取Socket的输入流，用来接收从服务端发送过来的数据        PrintWriter out=new PrintWriter(server.getOutputStream());        //获取Socket的输出流，用来发送数据到服务端        BufferedReader wt=new BufferedReader(new InputStreamReader(System.in));        //从键盘输入的数据流        while(true){            String str=wt.readLine();//读取键盘输入字符串            out.println(str);//发送数据到服务端            out.flush();            if(str.equals(&quot;end&quot;)){                break;            }            System.out.println(in.readLine());//打印服务器返回的字符串        }        server.close();//关闭连接    }}</code></pre><p><font color="blue">服务器程序1</font></p><pre><code class="lang-java">import java.io.*;import java.net.*;public class Server {    public static void main(String[] args) throws IOException{        ServerSocket server=new ServerSocket(5678);//通信端口        while(true){//一个客户端断开连接后，等待与另一个客户端建立连接            Socket client=server.accept();//accept用于产生&quot;阻塞&quot;，直到接受到一个连接，并且返回一个客户端的Socket对象实例。            BufferedReader in=                new BufferedReader(new InputStreamReader(client.getInputStream()));            PrintWriter out=new PrintWriter(client.getOutputStream());            while(true){//直到客户端发送end退出循环                String str=in.readLine();                System.out.println(str);                out.println(&quot;has receive....&quot;);                out.flush();                if(str.equals(&quot;end&quot;))                    break;               }               client.close();//关闭通信        }    }   }</code></pre><h3 id="2-多个客户端同时与服务器建立连接"><a href="#2-多个客户端同时与服务器建立连接" class="headerlink" title="2.多个客户端同时与服务器建立连接"></a>2.多个客户端同时与服务器建立连接</h3><p>客户端程序不变,服务器端阻塞等待客户端连接,并给每个链接分配一个线程  </p><p><font color="blue">服务器程序2</font></p><pre><code class="lang-java">import java.io.*;import java.net.*;public class Server extends Thread {//继承Thread类    private Socket client;    public Server(Socket c){//类初始化，接受参数为客户端的请求        this.client = c;    }    public void run(){//重写run函数        try{            BufferedReader in=                new BufferedReader(new InputStreamReader(client.getInputStream()));            PrintWriter out=new PrintWriter(client.getOutputStream());            while(true){                String str=in.readLine();                System.out.println(str);                out.println(&quot;has receive....&quot;);                out.flush();                if(str.equals(&quot;end&quot;))                    break;               }               client.close();        }catch(IOException ex){        }finally{        }    }    public static void main(String[] args) throws IOException{        ServerSocket server=new ServerSocket(5678);        while(true){            Server mu=new Server(server.accept());//每当有客户端请求就新建一个Server类与之通信            mu.start();//启动进程        }    }   }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> TCP </tag>
            
            <tag> java </tag>
            
            <tag> 聊天室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab函数freqs和freqz</title>
      <link href="/2017/Matlab%E5%87%BD%E6%95%B0freqs%E5%92%8Cfreqz/"/>
      <url>/2017/Matlab%E5%87%BD%E6%95%B0freqs%E5%92%8Cfreqz/</url>
      
        <content type="html"><![CDATA[<p>matlab中的freqs和freqz函数</p><h3 id="1-freqs"><a href="#1-freqs" class="headerlink" title="1.freqs"></a>1.freqs</h3><p>模拟滤波器的频率响应<br>语法：</p><pre><code class="lang-matlab">h = freqs(b,a,w)[h,w] = freqs(b,a)[h,w] = freqs(b,a,f)freqs(b,a)</code></pre><h4 id="1-1描述："><a href="#1-1描述：" class="headerlink" title="1.1描述："></a>1.1描述：</h4><p>freqs 返回一个模拟滤波器的H(jw)的复频域响应(拉普拉斯格式)</p><script type="math/tex; mode=display">H\left(s\right)=\frac{B\left(s\right)}{A\left(s\right)}=\frac{b\left(1\right)s^n+b\left(2\right)s^{n-1}+\dots+b\left(n+1\right)}{a\left(1\right)s^m+a\left(2\right)s^{m-1}+\dots+a\left(m+1\right)}</script><p>h = freqs(b, a, w) 根据系数向量计算返回模拟滤波器的复频域响应<br>freqs 计算在复平面虚轴上的频率响应h，角频率w确定了输入的实向量，因此必须包含至少一个频率点。<br>[h, w] = freqs(b, a) 自动挑选200个频率点来计算频率响应h<br>[h, w] = freqs(b, a, f) 挑选f个频率点来计算频率响应h  </p><h4 id="1-2例子："><a href="#1-2例子：" class="headerlink" title="1.2例子："></a>1.2例子：</h4><p>找到并画出下面传递函数的频率响应</p><script type="math/tex; mode=display">H\left(s\right)=\frac{0.2s^2+0.3s+1}{s^2+0.4s+1}</script><p>Matlab代码：</p><pre><code class="lang-matlab">a = [1 0.4 1];b = [0.2 0.3 1];w = logspace(-1, 1);freqs(b, a, w);</code></pre><p>logspace 功能：生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量<br>n如果省略，则默认值为50。  </p><pre><code class="lang-matlab">h=freqs(b,a,w);mag = abs(h);phase = angle(h);subplot(2,1,1), loglog(w,mag);subplot(2,1,2), semilogx(w,phase);f = w/(2*pi);mag = 20*log10(mag);phase = phase*180/pi;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2950376-b264b55b452e2e05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">  </p><h4 id="2-freqz"><a href="#2-freqz" class="headerlink" title="2.freqz"></a>2.freqz</h4><p>MATLAB提供了专门用于求离散系统频响特性的函数freqz()<br>调用freqz()的格式有以下两种：  </p><h3 id="2-1-H-w-freqz-B-A-N"><a href="#2-1-H-w-freqz-B-A-N" class="headerlink" title="2.1[H,w]=freqz(B,A,N)"></a>2.1[H,w]=freqz(B,A,N)</h3><script type="math/tex; mode=display">H\left(e^{jw}\right)=\frac{B\left(e^{jw}\right)}{A\left(e^{jw}\right)}=\frac{b\left(1\right)+b\left(2\right)e^{-jw}+b\left(2\right)e^{-j2w}+\dots+b\left(M\right)e^{-j\left(M-1\right)w}}{a\left(1\right)+a\left(2\right)e^{-jw}+a\left(2\right)e^{-j2w}+\dots+b\left(N\right)e^{-j\left(N-1\right)w}}</script><p>B和A分别为离散系统的系统函数分子、分母多项式的系数向量，N为正整数，返回量H则包含了离散系统频响 在 0——pi范围内N个频率等分点的值，向量w则包含范围内N个频率等分点。调用中若N默认，默认值为512。  </p><h4 id="2-2-H-w-freqz-B-A-N-’whole’"><a href="#2-2-H-w-freqz-B-A-N-’whole’" class="headerlink" title="2.2[H,w]=freqz(B,A,N,’whole’)"></a>2.2[H,w]=freqz(B,A,N,’whole’)</h4><p>该调用格式将计算离散系统在0—pi范内的N个频率等分店的频率响应的值。因此，可以先调用freqz()函数计算系统的频率响应，然后利用abs()和angle()函数及plot()函数，即可绘制出系统在 或 范围内的频响曲线。<br>例：绘制如下系统的频响曲线<br>H(z)=(z-0.5)/z<br>MATLAB命令如下：  </p><pre><code class="lang-matlab">B=[1 -0.5];A =[1 0];[H,w]=freqz(B,A,400,&#39;whole&#39;);</code></pre><p>H是频率响应的幅度，w是0—pi内的400个点  </p><pre><code class="lang-matlab">Hf=abs(H);Hx=angle(H);clffigure(1)plot(w,Hf)title(&#39;离散系统幅频特性曲线&#39;)figure(2)plot(w,Hx)title(&#39;离散系统相频特性曲线&#39;)</code></pre><p>幅频特性:<br><img src="http://upload-images.jianshu.io/upload_images/2950376-6cf701c431d25ecf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>相频特性:<br><img src="http://upload-images.jianshu.io/upload_images/2950376-2b3df07daa4591a4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>这样画出来的是线性的，要想获得db格式的幅度，需要转换 20*log10（Hf）<br>之后再画就是db格式的<br>也可以直接用freqz(b,a,w)这样就会画出幅频响应和相频响应，幅频响应直接是db格式的幅度。  </p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 数学工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 拉普拉斯变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涉及PyQt5的一些命令</title>
      <link href="/2017/%E6%B6%89%E5%8F%8APyQt5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/%E6%B6%89%E5%8F%8APyQt5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录pyqt5中用到的几个命令<br>安装</p><pre><code class="lang-sh">pip install python-qt5</code></pre><p>把ui转py</p><pre><code class="lang-sh">python -m PyQt5.uic.pyuic &lt;arguments&gt;</code></pre><p>lineEdit输入隐藏，密码</p><pre><code class="lang-python">lineEdit.setEchoMode(QtWidgets.QLineEdit.Password)</code></pre><p>py转exe</p><pre><code class="lang-sh">pip install pyinstallerpyinstaller demo.py</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">-F</td><td>指定打包后只生成一个exe格式的文件</td></tr><tr><td style="text-align:center">-D</td><td>–onedir创建一个目录,包含exe文件,但会依赖很多文件（默认选项）</td></tr><tr><td style="text-align:center">-c</td><td>–console,–nowindowed使用控制台,无界面(默认)</td></tr><tr><td style="text-align:center">-F</td><td>指定打包后只生成一个exe格式的文件</td></tr><tr><td style="text-align:center">-w</td><td>–windowed,–noconsole使用窗口,无控制台</td></tr><tr><td style="text-align:center">-p</td><td>添加搜索路径,让其找到对应的库。</td></tr><tr><td style="text-align:center">-i</td><td>改变生成程序的icon图标</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyqt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己写一个Android照相机应用-1</title>
      <link href="/2017/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-1/"/>
      <url>/2017/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-1/</url>
      
        <content type="html"><![CDATA[<p>Android相机的相关知识</p><h1 id="Android-Camera相关知识"><a href="#Android-Camera相关知识" class="headerlink" title="Android Camera相关知识"></a>Android Camera相关知识</h1><p>调用系统相机</p><pre><code class="lang-java">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//使用action启动系统相机//startActivity(intent);    //仅调用相机拍照，不返回数据//startActivityForResult(intent,REQ_1);//调用相机并通过onActivityResult函数data返回数据；Uri photoUri = Uri.fromFile(new File(mFilePath));//图片保存路径intent.putExtra(MediaStore.EXTRA_OUTPUT,photoUri);startActivityForResult(intent,REQ_2);//从文件中读取数据</code></pre><p>路径获取</p><pre><code class="lang-java">mFilePath = Environment.getExternalStorageDirectory().getPath();mFilePath = mFilePath + &quot;/&quot; + &quot;tmp.png&quot;;</code></pre><p>读取内存卡权限</p><pre><code class="lang-xml">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;</code></pre><p>onActivityResult函数</p><pre><code class="lang-java">protected void onActivityResult(int requestCode, int resultCode, Intent data) {    super.onActivityResult(requestCode, resultCode, data);    if(resultCode == RESULT_OK){        if (requestCode == REQ_1) {//从data获取照片            Bundle bundle = data.getExtras();            Bitmap bitmap = (Bitmap)bundle.get(&quot;data&quot;);            mImageView.setImageBitmap(bitmap);        } else if (requestCode == REQ_2) {//从文件获取照片            FileInputStream fis = null;            try {                fis = new FileInputStream(mFilePath);                Bitmap bitmap = BitmapFactory.decodeStream(fis);                mImageView.setImageBitmap(bitmap);            } catch (FileNotFoundException e) {                e.printStackTrace();            } finally {                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><p>注册action，实现照相功能</p><pre><code class="lang-xml">&lt;intent-filter&gt;        &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&lt;/intent-filter&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 相机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬瓦工VPS搭建Web服务器</title>
      <link href="/2017/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>记录在centos上安装apache+php+mysql<br>搬瓦工VPS<a href="https://bandwagonhost.com/aff.php?aff=17697" target="_blank" rel="noopener">购买地址</a>  </p><h1 id="1-安装apache"><a href="#1-安装apache" class="headerlink" title="1.安装apache"></a>1.安装apache</h1><p>安装<code>yum install httpd</code><br>启动<code>service httpd start</code><br>暂停<code>service httpd stop</code><br>重启<code>service httpd restart</code>  </p><p>检查开机启动情况<code>chkconfig --list httpd</code><br>默认情况下是全部关闭的，尽量设置开机启动，以防主机意外关机  </p><p>设置开机启动命令<code>chkconfig httpd on</code><br>再次检查启动情况，看到2，3，4，5为启动<br>关闭开机启动命令<code>chkconfig httpd off</code>  </p><p>到此Apache安装完成，在自己浏览器中输入主机IP和端口号能正常打开</p><h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2.安装php"></a>2.安装php</h1><p>命令为:</p><pre><code class="lang-sh">yum install phpyum install php-mysql  php-gd  php-imap  php-ldap  php-odbc php-pear  php-xml  php-xmlrpcyum install php-mysql</code></pre><p>以上命令为安装php及其支持的组件  </p><h1 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h1><h2 id="3-1安装"><a href="#3-1安装" class="headerlink" title="3.1安装"></a>3.1安装</h2><p>首先查看主机是否已经安装<code>rpm -qa|grep mysql</code><br>注意：可能检查中安装有php-mysql XXXXX 和 mysql-libXXXX,这是刚刚第二步安装的php的组件,不必理会  </p><p>已经安装的话就执行删除命令<code>rpm -e mysql</code>  </p><p>然后继续安装<br>使用命令yum list | grep mysql<br>来查看yum上提供的mysql数据库可下载的版本  </p><p>安装命令<code>yum install -y mysql-server mysql mysql-devel</code><br>等待一段时间安装成功</p><h2 id="3-2配置"><a href="#3-2配置" class="headerlink" title="3.2配置"></a>3.2配置</h2><p>接下来是对mysql的配置(<font color="red">注意:命令中是”mysqld”,不是mysql</font>)<br>初始化:<code>service mysqld start</code><br>重启:<code>service mysqld restart</code><br>配置开机自动启动:<code>chkconfig mysqld on</code>  </p><p>为mysql的root账户设置密码:<code>mysqladmin -u root password &#39;*********&#39;</code><br>登录命令<code>mysql -u root -p</code>  </p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> 搬瓦工 </tag>
            
            <tag> apache </tag>
            
            <tag> php </tag>
            
            <tag> mysql </tag>
            
            <tag> web </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python2与Python3共存</title>
      <link href="/2017/Python2%E4%B8%8EPython3%E5%85%B1%E5%AD%98/"/>
      <url>/2017/Python2%E4%B8%8EPython3%E5%85%B1%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>在windows下安装多个版本的python</p><h3 id="1-安装两个版本的Python"><a href="#1-安装两个版本的Python" class="headerlink" title="1.安装两个版本的Python"></a>1.安装两个版本的Python</h3><p>选择想要安装的版本下载例如:<br>python2下载地址:<a href="https://www.python.org/ftp/python/2.7.13/python-2.7.13.msi" target="_blank" rel="noopener">https://www.python.org/ftp/python/2.7.13/python-2.7.13.msi</a><br>python3下载地址:<a href="https://www.python.org/ftp/python/3.6.2/python-3.6.2.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.6.2/python-3.6.2.exe</a></p><p>进行安装(安装顺序随便)<br>尽量安装到同一目录下的两个文件夹例如:<br>python2安装在”D:\program\python27\”下<br>python3安装在”D:\program\python36\”下  </p><h3 id="2-添加环境变量"><a href="#2-添加环境变量" class="headerlink" title="2.添加环境变量"></a>2.添加环境变量</h3><p>Path中要有一下四个路径</p><pre><code>D:\program\python\Python36\Scripts\D:\program\python\Python36\D:\program\python\python27\ScriptsD:\program\python\python27\</code></pre><h3 id="3-更改python-exe名字"><a href="#3-更改python-exe名字" class="headerlink" title="3.更改python.exe名字"></a>3.更改python.exe名字</h3><p>找到找到两个python的安装目录<br><code>D:\program\python\Python36\python.exe</code><br>更改为<br><code>D:\program\python\Python36\python3.exe</code><br><code>D:\program\python\Python27\python.exe</code><br>更改为<br><code>D:\program\python\Python36\python2.exe</code><br>此时两个版本的python已经共同存在<br>但还要对pip进行修改</p><h3 id="4-更改pip名称"><a href="#4-更改pip名称" class="headerlink" title="4.更改pip名称"></a>4.更改pip名称</h3><p>重装python2和python3的pip  </p><pre><code class="lang-sh">python2 -m pip install --upgrade pip --force-reinstallpython3 -m pip install --upgrade pip --force-reinstall</code></pre><p>重装成功后进行如下测试<br>test.PNG…<br>可见python2和python3已经共存<br>pip的问题也解决了<br>但直接调用pip是还能执行并且是后安装的pip的版本<br>python命令已经不存在<br>直接运行py结尾的文件时会出现问题<br>python自带的编辑器出现了两个  </p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬瓦工安装ss并加速</title>
      <link href="/2017/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%89%E8%A3%85ss%E5%B9%B6%E5%8A%A0%E9%80%9F/"/>
      <url>/2017/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%89%E8%A3%85ss%E5%B9%B6%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<p>通过搬瓦工的VPS安装ss的几种方法</p><p>搬瓦工（BandwagonHost）是美国IT7公司旗下的一家提供便宜年付OVZ架构的VPS主机方案的服务商。价格便宜、且依托的商家比较靠谱，具有较高的性价比。拿来搭个FQ是非常合适的，做个小站也是可以的。</p><h1 id="1-购买地址"><a href="#1-购买地址" class="headerlink" title="1.购买地址"></a>1.购买地址</h1><blockquote><p>搬瓦工所有配置及购买地址:<a href="https://bandwagonhost.com/aff.php?aff=17697" target="_blank" rel="noopener">https://bandwagonhost.com/aff.php?aff=17697</a> 以前有小内存的VPS年费三刀，很便宜，但现在没有了，缺货，连521M的有时候也会缺货，看来挺火的。</p></blockquote><h1 id="2-安装Shadowsocks"><a href="#2-安装Shadowsocks" class="headerlink" title="2.安装Shadowsocks"></a>2.安装Shadowsocks</h1><h2 id="2-1搬瓦工后台一键安装-不推荐"><a href="#2-1搬瓦工后台一键安装-不推荐" class="headerlink" title="2.1搬瓦工后台一键安装(不推荐)"></a>2.1搬瓦工后台一键安装(不推荐)</h2><p>登录账号-&gt;Client Area-&gt;Services-&gt;My Services-&gt;KiwiVM Control Panel<br>来到管理面板，点击 Shadowsocks Server 就可以一键安装 Shadowsocks<br>测试过它自带的一键安装，速度太慢，yotube视频看不了，有点慢。</p><h2 id="2-2使用shell脚本安装-推荐"><a href="#2-2使用shell脚本安装-推荐" class="headerlink" title="2.2使用shell脚本安装(推荐)"></a>2.2使用shell脚本安装(推荐)</h2><h3 id="2-2-1安装-shadowsoksR"><a href="#2-2-1安装-shadowsoksR" class="headerlink" title="2.2.1安装 shadowsoksR"></a>2.2.1安装 shadowsoksR</h3><p>Shadowsocks的一个分支，比较不错。但是默认是 aes-256-cfb 加密，如果需要 chacha20 加密，需要手动切换。</p><pre><code class="lang-sh">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</code></pre><p>安装成功需要等几分钟<br>这个速度可以看yotube无压力</p><p>卸载方法：<br>使用 root 用户登录，运行以下命令：</p><pre><code class="lang-sh">./shadowsocksR.sh uninstall</code></pre><p>安装完成后即已后台启动 ShadowsocksR,运行：</p><pre><code>/etc/init.d/shadowsocks status</code></pre><p>可以查看 ShadowsocksR 进程是否已经启动。<br>本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。</p><p>其它命令：<br>启动：/etc/init.d/shadowsocks start<br>停止：/etc/init.d/shadowsocks stop<br>重启：/etc/init.d/shadowsocks restart<br>状态：/etc/init.d/shadowsocks status  </p><p>配置文件路径：/etc/shadowsocks.json<br>日志文件路径：/var/log/shadowsocks.log<br>代码安装目录：/usr/local/shadowsocks  </p><h3 id="2-2-2安装-shadowsocks-go版本"><a href="#2-2-2安装-shadowsocks-go版本" class="headerlink" title="2.2.2安装 shadowsocks-go版本"></a>2.2.2安装 shadowsocks-go版本</h3><p>据说有buff，比python版Shadowsocks要快：</p><pre><code class="lang-sh">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-go.log</code></pre><h3 id="2-2-3其他版本Shadowsocks一键安装："><a href="#2-2-3其他版本Shadowsocks一键安装：" class="headerlink" title="2.2.3其他版本Shadowsocks一键安装："></a>2.2.3其他版本Shadowsocks一键安装：</h3><p>来自 teddysun：<a href="https://github.com/teddysun/shadowsocks_install" target="_blank" rel="noopener">https://github.com/teddysun/shadowsocks_install</a></p><h1 id="3-遇到的一些问题"><a href="#3-遇到的一些问题" class="headerlink" title="3.遇到的一些问题"></a>3.遇到的一些问题</h1><h2 id="3-1搬瓦工默认系统Centos没有wget命令需要安装"><a href="#3-1搬瓦工默认系统Centos没有wget命令需要安装" class="headerlink" title="3.1搬瓦工默认系统Centos没有wget命令需要安装"></a>3.1搬瓦工默认系统Centos没有wget命令需要安装</h2><p>安装命令:</p><pre><code>yum -y install wget</code></pre><h2 id="3-2关于配置多用户"><a href="#3-2关于配置多用户" class="headerlink" title="3.2关于配置多用户"></a>3.2关于配置多用户</h2><pre><code class="lang-sh">vi /etc/shadowsocks.json</code></pre><p>只需要在port_password项下添加”端口号”:”密码”</p><pre><code class="lang-json">{    &quot;server&quot;:&quot;0.0.0.0&quot;,    &quot;server_ipv6&quot;:&quot;[::]&quot;,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;port_password&quot;:{        &quot;12345&quot;: &quot;123456&quot;,        &quot;23456&quot;: &quot;123456&quot;    },    &quot;timeout&quot;:120,    &quot;method&quot;:&quot;aes-256-cfb&quot;,    &quot;protocol&quot;:&quot;origin&quot;,    &quot;protocol_param&quot;:&quot;&quot;,    &quot;obfs&quot;:&quot;plain&quot;,    &quot;obfs_param&quot;:&quot;&quot;,    &quot;redirect&quot;:&quot;&quot;,    &quot;dns_ipv6&quot;:false,    &quot;fast_open&quot;:false,    &quot;workers&quot;:1}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1.<a href="https://blog.kuoruan.com/48.html" target="_blank" rel="noopener">https://blog.kuoruan.com/48.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> 搬瓦工 </tag>
            
            <tag> shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA实现MD5加密</title>
      <link href="/2017/JAVA%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86/"/>
      <url>/2017/JAVA%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>java实现MD5加密的两种方法</p><p>1,调用MessageDigest实现</p><pre><code class="lang-java">import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class CreatMD5 {    public String getMd5(String plainText){        try {              MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);              md.update(plainText.getBytes());              byte b[] = md.digest();              int i;              StringBuffer buf = new StringBuffer(&quot;&quot;);              for (int offset = 0; offset &lt; b.length; offset++) {                  i = b[offset];                  if (i &lt; 0)                      i += 256;                  if (i &lt; 16)                      buf.append(&quot;0&quot;);                  buf.append(Integer.toHexString(i));              }              //32位加密              return buf.toString();              // 16位的加密              //return buf.toString().substring(8, 24);          } catch (NoSuchAlgorithmException e) {              e.printStackTrace();              return null;          }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        CreatMD5 md=new CreatMD5();        System.out.println(md.getMd5(&quot;hello&quot;));    }}</code></pre><p>2,自己编写函数实现</p><pre><code class="lang-java">public class CreateMD5i {    static final String hexs[]={&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;};    //标准的幻数    private static final long A=0x67452301L;    private static final long B=0xefcdab89L;    private static final long C=0x98badcfeL;    private static final long D=0x10325476L;    //下面这些S11-S44实际上是一个4*4的矩阵，在四轮循环运算中用到    static final int S11 = 7;    static final int S12 = 12;    static final int S13 = 17;    static final int S14 = 22;    static final int S21 = 5;    static final int S22 = 9;    static final int S23 = 14;    static final int S24 = 20;    static final int S31 = 4;    static final int S32 = 11;    static final int S33 = 16;    static final int S34 = 23;    static final int S41 = 6;    static final int S42 = 10;    static final int S43 = 15;    static final int S44 = 21;    //java不支持无符号的基本数据（unsigned）    private long [] result={A,B,C,D};//存储hash结果，共4×32=128位，初始化值为（幻数的级联）    public static void main(String []args){        CreateMD5i md=new CreateMD5i();        System.out.println(&quot;md5(hello)=&quot;+md.digest(&quot;hello&quot;));    }    public String digest(String inputStr){        byte [] inputBytes=inputStr.getBytes();        int byteLen=inputBytes.length;//长度（字节）        int groupCount=0;//完整分组的个数        groupCount=byteLen/64;//每组512位（64字节）        long []groups=null;//每个小组(64字节)再细分后的16个小组(4字节)        //处理每一个完整 分组        for(int step=0;step&lt;groupCount;step++){            groups=divGroup(inputBytes,step*64);            trans(groups);//处理分组，核心算法        }        //处理完整分组后的尾巴        int rest=byteLen%64;//512位分组后的余数        byte [] tempBytes=new byte[64];        if(rest&lt;=56){            for(int i=0;i&lt;rest;i++)                tempBytes[i]=inputBytes[byteLen-rest+i];            if(rest&lt;56){                tempBytes[rest]=(byte)(1&lt;&lt;7);                for(int i=1;i&lt;56-rest;i++)                    tempBytes[rest+i]=0;            }            long len=(long)(byteLen&lt;&lt;3);            for(int i=0;i&lt;8;i++){                tempBytes[56+i]=(byte)(len&amp;0xFFL);                len=len&gt;&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }else{            for(int i=0;i&lt;rest;i++)                tempBytes[i]=inputBytes[byteLen-rest+i];            tempBytes[rest]=(byte)(1&lt;&lt;7);            for(int i=rest+1;i&lt;64;i++)                tempBytes[i]=0;            groups=divGroup(tempBytes,0);            trans(groups);//处理分组            for(int i=0;i&lt;56;i++)                tempBytes[i]=0;            long len=(long)(byteLen&lt;&lt;3);            for(int i=0;i&lt;8;i++){                tempBytes[56+i]=(byte)(len&amp;0xFFL);                len=len&gt;&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }        //将Hash值转换成十六进制的字符串        String resStr=&quot;&quot;;        long temp=0;        for(int i=0;i&lt;4;i++){            for(int j=0;j&lt;4;j++){                temp=result[i]&amp;0x0FL;                String a=hexs[(int)(temp)];                result[i]=result[i]&gt;&gt;4;                temp=result[i]&amp;0x0FL;                resStr+=hexs[(int)(temp)]+a;                result[i]=result[i]&gt;&gt;4;            }        }        return resStr;    }    /**     * 从inputBytes的index开始取512位，作为新的分组     * 将每一个512位的分组再细分成16个小组，每个小组64位（8个字节）     * @param inputBytes     * @param index     * @return     */    private static long[] divGroup(byte[] inputBytes,int index){        long [] temp=new long[16];        for(int i=0;i&lt;16;i++){            temp[i]=b2iu(inputBytes[4*i+index])|                (b2iu(inputBytes[4*i+1+index]))&lt;&lt;8|                (b2iu(inputBytes[4*i+2+index]))&lt;&lt;16|                (b2iu(inputBytes[4*i+3+index]))&lt;&lt;24;        }        return temp;    }    /**     * 这时不存在符号位（符号位存储不再是代表正负），所以需要处理一下     * @param b     * @return     */    public static long b2iu(byte b){        return b &lt; 0 ? b &amp; 0x7F + 128 : b;     }    /**     * 主要的操作，四轮循环     * @param groups[]--每一个分组512位（64字节）     */    private void trans(long[] groups) {        long a = result[0], b = result[1], c = result[2], d = result[3];        /*第一轮*/        a = FF(a, b, c, d, groups[0], S11, 0xd76aa478L); /* 1 */        d = FF(d, a, b, c, groups[1], S12, 0xe8c7b756L); /* 2 */        c = FF(c, d, a, b, groups[2], S13, 0x242070dbL); /* 3 */        b = FF(b, c, d, a, groups[3], S14, 0xc1bdceeeL); /* 4 */        a = FF(a, b, c, d, groups[4], S11, 0xf57c0fafL); /* 5 */        d = FF(d, a, b, c, groups[5], S12, 0x4787c62aL); /* 6 */        c = FF(c, d, a, b, groups[6], S13, 0xa8304613L); /* 7 */        b = FF(b, c, d, a, groups[7], S14, 0xfd469501L); /* 8 */        a = FF(a, b, c, d, groups[8], S11, 0x698098d8L); /* 9 */        d = FF(d, a, b, c, groups[9], S12, 0x8b44f7afL); /* 10 */        c = FF(c, d, a, b, groups[10], S13, 0xffff5bb1L); /* 11 */        b = FF(b, c, d, a, groups[11], S14, 0x895cd7beL); /* 12 */        a = FF(a, b, c, d, groups[12], S11, 0x6b901122L); /* 13 */        d = FF(d, a, b, c, groups[13], S12, 0xfd987193L); /* 14 */        c = FF(c, d, a, b, groups[14], S13, 0xa679438eL); /* 15 */        b = FF(b, c, d, a, groups[15], S14, 0x49b40821L); /* 16 */        /*第二轮*/        a = GG(a, b, c, d, groups[1], S21, 0xf61e2562L); /* 17 */        d = GG(d, a, b, c, groups[6], S22, 0xc040b340L); /* 18 */        c = GG(c, d, a, b, groups[11], S23, 0x265e5a51L); /* 19 */        b = GG(b, c, d, a, groups[0], S24, 0xe9b6c7aaL); /* 20 */        a = GG(a, b, c, d, groups[5], S21, 0xd62f105dL); /* 21 */        d = GG(d, a, b, c, groups[10], S22, 0x2441453L); /* 22 */        c = GG(c, d, a, b, groups[15], S23, 0xd8a1e681L); /* 23 */        b = GG(b, c, d, a, groups[4], S24, 0xe7d3fbc8L); /* 24 */        a = GG(a, b, c, d, groups[9], S21, 0x21e1cde6L); /* 25 */        d = GG(d, a, b, c, groups[14], S22, 0xc33707d6L); /* 26 */        c = GG(c, d, a, b, groups[3], S23, 0xf4d50d87L); /* 27 */        b = GG(b, c, d, a, groups[8], S24, 0x455a14edL); /* 28 */        a = GG(a, b, c, d, groups[13], S21, 0xa9e3e905L); /* 29 */        d = GG(d, a, b, c, groups[2], S22, 0xfcefa3f8L); /* 30 */        c = GG(c, d, a, b, groups[7], S23, 0x676f02d9L); /* 31 */        b = GG(b, c, d, a, groups[12], S24, 0x8d2a4c8aL); /* 32 */        /*第三轮*/        a = HH(a, b, c, d, groups[5], S31, 0xfffa3942L); /* 33 */        d = HH(d, a, b, c, groups[8], S32, 0x8771f681L); /* 34 */        c = HH(c, d, a, b, groups[11], S33, 0x6d9d6122L); /* 35 */        b = HH(b, c, d, a, groups[14], S34, 0xfde5380cL); /* 36 */        a = HH(a, b, c, d, groups[1], S31, 0xa4beea44L); /* 37 */        d = HH(d, a, b, c, groups[4], S32, 0x4bdecfa9L); /* 38 */        c = HH(c, d, a, b, groups[7], S33, 0xf6bb4b60L); /* 39 */        b = HH(b, c, d, a, groups[10], S34, 0xbebfbc70L); /* 40 */        a = HH(a, b, c, d, groups[13], S31, 0x289b7ec6L); /* 41 */        d = HH(d, a, b, c, groups[0], S32, 0xeaa127faL); /* 42 */        c = HH(c, d, a, b, groups[3], S33, 0xd4ef3085L); /* 43 */        b = HH(b, c, d, a, groups[6], S34, 0x4881d05L); /* 44 */        a = HH(a, b, c, d, groups[9], S31, 0xd9d4d039L); /* 45 */        d = HH(d, a, b, c, groups[12], S32, 0xe6db99e5L); /* 46 */        c = HH(c, d, a, b, groups[15], S33, 0x1fa27cf8L); /* 47 */        b = HH(b, c, d, a, groups[2], S34, 0xc4ac5665L); /* 48 */        /*第四轮*/        a = II(a, b, c, d, groups[0], S41, 0xf4292244L); /* 49 */        d = II(d, a, b, c, groups[7], S42, 0x432aff97L); /* 50 */        c = II(c, d, a, b, groups[14], S43, 0xab9423a7L); /* 51 */        b = II(b, c, d, a, groups[5], S44, 0xfc93a039L); /* 52 */        a = II(a, b, c, d, groups[12], S41, 0x655b59c3L); /* 53 */        d = II(d, a, b, c, groups[3], S42, 0x8f0ccc92L); /* 54 */        c = II(c, d, a, b, groups[10], S43, 0xffeff47dL); /* 55 */        b = II(b, c, d, a, groups[1], S44, 0x85845dd1L); /* 56 */        a = II(a, b, c, d, groups[8], S41, 0x6fa87e4fL); /* 57 */        d = II(d, a, b, c, groups[15], S42, 0xfe2ce6e0L); /* 58 */        c = II(c, d, a, b, groups[6], S43, 0xa3014314L); /* 59 */        b = II(b, c, d, a, groups[13], S44, 0x4e0811a1L); /* 60 */        a = II(a, b, c, d, groups[4], S41, 0xf7537e82L); /* 61 */        d = II(d, a, b, c, groups[11], S42, 0xbd3af235L); /* 62 */        c = II(c, d, a, b, groups[2], S43, 0x2ad7d2bbL); /* 63 */        b = II(b, c, d, a, groups[9], S44, 0xeb86d391L); /* 64 */        /*加入到之前计算的结果当中*/        result[0] += a;        result[1] += b;        result[2] += c;        result[3] += d;        result[0]=result[0]&amp;0xFFFFFFFFL;        result[1]=result[1]&amp;0xFFFFFFFFL;        result[2]=result[2]&amp;0xFFFFFFFFL;        result[3]=result[3]&amp;0xFFFFFFFFL;    }    /**     * 下面是处理要用到的线性函数     */    private static long F(long x, long y, long z) {        return (x &amp; y) | ((~x) &amp; z);    }    private static long G(long x, long y, long z) {        return (x &amp; z) | (y &amp; (~z));    }    private static long H(long x, long y, long z) {        return x ^ y ^ z;    }    private static long I(long x, long y, long z) {        return y ^ (x | (~z));    }    private static long FF(long a, long b, long c, long d, long x, long s,            long ac) {        a += (F(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL)&lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long GG(long a, long b, long c, long d, long x, long s,            long ac) {        a += (G(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long HH(long a, long b, long c, long d, long x, long s,            long ac) {        a += (H(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long II(long a, long b, long c, long d, long x, long s,            long ac) {        a += (I(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> MD5 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器运行安卓APK</title>
      <link href="/2017/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93apk/"/>
      <url>/2017/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93apk/</url>
      
        <content type="html"><![CDATA[<p>使用谷歌浏览器的插件ARChon实现安卓APK在电脑上运行 </p><p>用谷歌插件在电脑上运行安卓APK</p><p>1，直接谷歌应用商店下载出现错误<br>程序包无效：“CRX_SIGNATURE_VERIFICATION_FAILED”。</p><p>2，直接下载crx包参考百度经验</p><p>3，出现错误：Cannot load extension with file or directory name <em>metadata. Filenames starting with “</em>” are reserved for use by the system.<br>更改解压后文件夹_metadata为metadata</p><p>4，出现错误：’import’ extension is not installed.<br>打开文件manifest.json去掉import一句</p><pre><code>&quot;import&quot;:[{&quot;id&quot;:&quot;mfaihdlpglflfgpfjcifdjdjcckigekc&quot;}],</code></pre><p>继续谷歌去掉这句话不对<br>看这篇CSDN文章<br>说要下载插件ARChon<br>(以下废话，直接看5）</p><p>4.1，安装成功，但启用后一直白屏</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-a275f201f7fdead8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>怀疑是不是去掉import一句出问题了</p><p>4.2，网上看到开启Native Client<br>谷歌浏览器地址栏输入chrome://flags/开启Native Client<br>无用</p><p>4.3，发现另一个谷歌商店的应用twerk这个应用是把 APK 文件转换成 Chrome App用的</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-2372cf692c93b5a9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>5ARChon是谷歌插件要在扩展程序，打钩开发者模式，点击加载已解压扩展程序，选择解压文件夹<br>加载ARChon时有警告，可忽略<br>先加载ARC Welder出现4的错误后<br>再加载ARChon，然后ARC Welder就好了，不好的话重新加载就好了<br>安装好了就是APK运行不了</p><p>4.3安装的twerk可以把 APK 文件转换一个文件夹<br>然后ARC Welder运行<br>谷歌浏览器如何运行APK博客CSDN可以试一试</p><h2 id="又遇到的问题"><a href="#又遇到的问题" class="headerlink" title="又遇到的问题"></a>又遇到的问题</h2><p>Chrome加载Android应用，提示“There is no “message” element for key extName”错误，如：</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-0c0702ed3e06b504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>找到该Crx文件夹下的”_locales\en”目录下的”messages.json”文件，在”extName”节点下，添加”message”字段标签，值对应应用的包名：</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-c5a40ac2756b5a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>WebGL 不受支持<br>知乎有教程<br>浏览器快捷方式属性增加—ignore-gpu-blacklist<br>开启硬件加速<br>试了一下掌阅</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-f4ed0ddb2b2d06e1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>试了一下简书<br>可以运行</p><p><img src="http://upload-images.jianshu.io/upload_images/2950376-ed37c301d49d7485.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓模拟器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理for循环使用</title>
      <link href="/2017/%E6%89%B9%E5%A4%84%E7%90%86for%E5%BE%AA%E7%8E%AF/"/>
      <url>/2017/%E6%89%B9%E5%A4%84%E7%90%86for%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>windows批处理FOR循环的使用</p><p>在cmd中输入使用时应写为</p><pre><code>FOR %variable IN (set) DO command [command-parameters]</code></pre><p>command [command-parameters]中用到变量也要写为%variable<br>写进.bat或者.cmd文件时应写为</p><pre><code>FOR %%variable IN (set) DO command [command-parameters]</code></pre><p>command [command-parameters]中用到变量也要写为%%variable<br>Windows自带的help解释:</p><pre><code class="lang-dos">FOR %variable IN (set) DO command [command-parameters]    ::%variable  指定一个单一字母可替换的参数。    ::(set)      指定一个或一组文件。可以使用通配符。    ::command    指定对每个文件执行的命令。    ::command-parameters  为特定命令指定参数或命令行开关。</code></pre><p>在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable而不要用 %variable。<br>变量名称是区分大小写的，所以 %i 不同于 %I.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> bat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
