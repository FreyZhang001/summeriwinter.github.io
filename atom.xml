<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frey&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vhcffh.com/"/>
  <updated>2019-08-10T15:26:32.733Z</updated>
  <id>https://www.vhcffh.com/</id>
  
  <author>
    <name>Frey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mathjax配置问题</title>
    <link href="https://www.vhcffh.com/2019/mathjax%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>https://www.vhcffh.com/2019/mathjax配置问题/</id>
    <published>2019-08-10T15:07:51.000Z</published>
    <updated>2019-08-10T15:26:32.733Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo时，想要实现网页中公式的渲染<br>发现不管怎么改，都不能渲染单行公式<br>最后发现是在mathjax的2.3版本以后，配置方法变了</p><h3 id="mathjax的配置方法"><a href="#mathjax的配置方法" class="headerlink" title="mathjax的配置方法"></a>mathjax的配置方法</h3><p>一般网上大部分的mathjax的配置如下</p><pre><code class="lang-html">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  });&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;path-to-MathJax/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;</code></pre><p>其中配置中这一句主要是增加对单行公式的渲染</p><pre><code class="lang-javascript">inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],</code></pre><p>有时候会发现无论如修改单行公式总是不能渲染<br>原因是在mathjax的2.3版本以后，应该这样配置</p><pre><code class="lang-html">&lt;script type=&quot;text/javascript&quot;&gt;  window.MathJax = {    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  };&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;path-to-MathJax/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1,<a href="https://docs.mathjax.org/en/latest/configuration.html" target="_blank" rel="noopener">https://docs.mathjax.org/en/latest/configuration.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用hexo时，想要实现网页中公式的渲染&lt;br&gt;发现不管怎么改，都不能渲染单行公式&lt;br&gt;最后发现是在mathjax的2.3版本以后，配置方法变了&lt;/p&gt;
&lt;h3 id=&quot;mathjax的配置方法&quot;&gt;&lt;a href=&quot;#mathjax的配置方法&quot; class=&quot;header
      
    
    </summary>
    
      <category term="软件使用" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="mathjax" scheme="https://www.vhcffh.com/tags/mathjax/"/>
    
  </entry>
  
  <entry>
    <title>神经网络中的前向传播与后向传播</title>
    <link href="https://www.vhcffh.com/2019/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%90%8E%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <id>https://www.vhcffh.com/2019/神经网络中的前向传播与后向传播/</id>
    <published>2019-07-10T13:22:25.000Z</published>
    <updated>2019-08-10T14:08:23.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2019/7_10_neu.png" alt="img"></p><p>$f(z)$为激励函数，关于激励函数(又称激活函数)的总结<br>隐藏层1输入</p><script type="math/tex; mode=display">z^{(1)}=W^{(1)}x^T+b^{(1)}\label{1}\tag{1}</script><p>隐藏层1输出</p><script type="math/tex; mode=display">n^{(1)}=f^{(1)}(z^{(1)})\label{2}\tag{2}</script><p>隐藏层2输入</p><script type="math/tex; mode=display">z^{(2)}=W^{(2)}n^{(1)}+b^{(2)}\label{3}\tag{3}</script><p>隐藏层2输出</p><script type="math/tex; mode=display">n^{(2)}=f^{(2)}(z^{(2)})\label{4}\tag{4}</script><p>隐藏层3输入</p><script type="math/tex; mode=display">z^{(3)}=W^{(3)}n^{(2)}+b^{(3)}\label{5}\tag{5}</script><p>隐藏层3输出即输出层</p><script type="math/tex; mode=display">\widehat y = n^{(3)}= f^{(3)}(z{(3)})\label{6}\tag{6}</script><p>损失函数</p><script type="math/tex; mode=display">L(y,\widehat y)\label{7}\tag{7}</script><p>即隐藏层k+1输入</p><script type="math/tex; mode=display">z^{(k+1)}=W^{(k+1)}n^{(k)}+b^{(k+1)}\label{8}\tag{8}</script><p>隐藏层k+1输出</p><script type="math/tex; mode=display">n^{(k+1)}= f^{(k+1)}(z{(k+1)})\label{9}\tag{9}</script><p>对损失函数进行总结<a href="https://blog.csdn.net/lien0906/article/details/78429768" target="_blank" rel="noopener">https://blog.csdn.net/lien0906/article/details/78429768</a><br>计算偏导数</p><script type="math/tex; mode=display">\frac {\partial z^{(k)}}{\partial b^{(k)}}=\begin{bmatrix}\frac{\partial (W^{(k)}_{[1,:]}*n^{(k-1)}+b_1)}{\partial b_1} & \ldots & \frac{\partial (W^{(k)}_{[1,:]}*n^{(k-1)}+b_1)}{\partial b_m}\\\vdots & \ddots & \vdots\\\frac{\partial (W^{(k)}_{[m,:]}*n^{(k-1)}+b_m)}{\partial b_1}  &\ldots & \frac{\partial (W^{(k)}_{[m,:]}*n^{(k-1)}+b_m)}{\partial b_m}\end{bmatrix}=diag(1,1, \ldots ,1)\label{10}\tag{10}</script><p>列向量对列向量求导参见矩阵中的求导</p><p>计算偏导数$\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}​$ </p><p>偏导数$\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}$ 又称误差项(error term,也称“灵敏度”),一般用$\delta$ 表示,用$\delta^{(k)}$ 表示第k层神经元的误差项,其值的大小代表了<strong>第k层神经元对最终总误差的影响大小</strong> </p><script type="math/tex; mode=display">\begin{align}\delta^{(k)} & = \frac {\partial L(y,\widehat y)}{\partial z^{(k)}}\\& =\frac {\partial n^{(k)}}{\partial z^{(k)}}*\frac {\partial z^{(k+1)}}{\partial n^{(k)}}*\frac {\partial L(y,\widehat y)}{\partial z^{(k+1)}}\\& = {f^{(k)}}^{'}(z^{(k)}) * (W^{(k+1)})^T * \delta^{(k+1)}\end{align}\label{11}\tag{11}</script><p>最终需要用的两个导数</p><script type="math/tex; mode=display">\frac {\partial L(y,\widehat y)}{\partial W^{(k)}}=\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}*\frac {\partial z^{(k)}}{\partial W^{(k)}}=\delta^{(k)}*(n^{(k-1)})^T\label{12}\tag{12}</script><script type="math/tex; mode=display">\frac {\partial L(y,\widehat y)}{\partial b^{(k)}}=\frac {\partial L(y,\widehat y)}{\partial z^{(k)}}*\frac {\partial z^{(k)}}{\partial b^{(k)}}=\delta^{(k)}\label{13}\tag{13}</script><p>后向传播参数更新</p><script type="math/tex; mode=display">W^{(k)} = W^{(k)} - \alpha(\delta^{(k)}(n^{(k-1)})^T + W^{(k)})\label{14}\tag{14}\\</script><script type="math/tex; mode=display">b^{(k)} = b^{(k)}-\alpha\delta^{(k)}\label{15}\tag{15}</script><p>其中$\alpha$ 是学习率</p><p>后向传播中的正则化,L1正则化,L2正则化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2019/7_10_neu.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;$f(z)$为激励函数，关于激励函数(又称激活函数)的总结&lt;br&gt;隐藏层1输入&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
      
    
    </summary>
    
      <category term="深度学习" scheme="https://www.vhcffh.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="BP算法" scheme="https://www.vhcffh.com/tags/BP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习中Keras vs Pytorch</title>
    <link href="https://www.vhcffh.com/2019/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADKeras%20vs%20Pytorch/"/>
    <id>https://www.vhcffh.com/2019/深度学习中Keras vs Pytorch/</id>
    <published>2019-07-09T00:11:00.000Z</published>
    <updated>2019-08-10T12:58:17.469Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习框架Keras与Pytorch的区别与优劣<a href="https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d" target="_blank" rel="noopener">翻译</a><br><img src="/images/2019/7_11_pytorchvskears.png" alt="img" title="Keras vs PyTorch"></p><p>对于许多科学家，工程师和开发人员来说，TensorFlow是他们的第一个深度学习框架。 TensorFlow 1.0于2017年2月发布;但它对用户来说不是很友好。</p><p>在过去几年中，两个主要的深度学习库已经获得了巨大的普及，主要是因为它们比TensorFlow更容易使用：<strong>Keras</strong>和<strong>Pytorch</strong>。</p><p>本文将介绍Keras与Pytorch的4个不同点，以及为什么您可以选择一个库而不是另一个库。</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>Keras本身不是一个框架，但实际上是一个位于其他Deep Learning框架之上的高级API。目前它支持<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>，<a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a>和<a href="https://github.com/microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>。</p><p>Keras的优势在于它的易用性。它是迄今为止最容易去快速启动和运行的框架。定义神经网络非常直观，使用功能API允许人们将层定义为函数。</p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><p>Pytorch是由Facebook的AI研究小组开发的深度学习框架（如TensorFlow）。像Keras一样，它也对深度网络编程中比较复杂的一大部分进行了抽象。</p><p>在高级和低级编码风格方面，Pytorch位于Keras和TensorFlow之间。你比Keras有更多的灵活性和控制力，但与此同时你不必做任何疯狂的声明性编程。</p><p>深度学习练习者整天都在争论应该使用哪个框架。一般来说，这取决于个人喜好。但是在选择时你应该记住Keras和Pytorch的一些特性。</p><p><img src="/images/2019/7_10_keras.jpeg" alt="img" title="It&#39;s keras"></p><p><img src="/images/2019/7_10_pytorch.jpeg" alt="img" title="It&#39;s Pytorch!"></p><h2 id="1-用于定义模型的-类-Pytorch-vs-函数-Keras"><a href="#1-用于定义模型的-类-Pytorch-vs-函数-Keras" class="headerlink" title="(1)用于定义模型的 类(Pytorch) vs 函数(Keras)"></a>(1)用于定义模型的 类(Pytorch) vs 函数(Keras)</h2><p>要定义深度学习模型，Keras提供Functional API。 使用Functional API，神经网络被定义为一组顺序函数，一个接一个地应用。 例如，第一层的输出是第二层的输入。</p><pre><code class="lang-python">img_input = layers.Input(shape=input_shape)x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(img_input)    x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(x)    x = layers.MaxPooling2D((2, 2), strides=(2, 2))(x)</code></pre><p>在Pytorch中，您将网络设置为一个类，该类继承了Torch库中的torch.nn.Module。 与Keras类似，Pytorch为您提供了层作为构建块，但由于它们位于Python类中，因此它们在类的__init__()方法中引用，并由类的forward()方法执行。</p><pre><code class="lang-python">class Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(3, 64, 3)        self.conv2 = nn.Conv2d(64, 64, 3)        self.pool = nn.MaxPool2d(2, 2)    def forward(self, x):        x = F.relu(self.conv1(x))        x = self.pool(F.relu(self.conv2(x)))        return xmodel = Net()</code></pre><p>因为Pytorch允许您访问所有Python的类功能而不是简单的函数调用，所以定义网络可以更清晰，更优雅地包含。 这真的没什么不好的，除非你觉得最重要的是尽可能快地编写代码，那么Keras会更容易使用。</p><h2 id="2-张量和计算图-Pytorch-vs-标准阵列-Keras"><a href="#2-张量和计算图-Pytorch-vs-标准阵列-Keras" class="headerlink" title="(2)张量和计算图(Pytorch) vs 标准阵列(Keras)"></a>(2)张量和计算图(Pytorch) vs 标准阵列(Keras)</h2><p>Keras API对程序员隐藏了的许多复杂细节。定义网络层非常直观，默认设置通常足以让您入门。</p><p>只有当你需要实现一个相当尖端或“异国情调”的模型时，你才真正需要去了解底层的TensorFlow。</p><p>棘手的部分是，当你真正去了解底层的TensorFlow代码时，你将获得随之而来的所有非常具有挑战性的部分！ 您需要确保所有矩阵乘法都排成一行。 哦，甚至不要去考虑尝试打印出图层的一个输出，因为您只能在终端上打印出一个漂亮的Tensor定义。</p><p>Pytorch在这些方面倾向于更加方便。 您需要知道每个层的输入和输出大小，但这可以很快掌握。 您不必处理构建一个您无法在调试中看到的抽象计算图。</p><p>Pytorch的另一个好处是你可以在Torch Tensors和Numpy阵列之间来回滑动。 如果你需要实现自定义的东西，那么在TF张量和Numpy阵列之间来回转换可能会很麻烦，需要开发人员对TensorFlow的Session有充分的了解。</p><p>Pytorch的交互性比想象中要简单得多。 您只需要知道两个操作：一个将Torch Tensor（一个Variable对象）转变到Numpy，另一个是相反的转换。</p><pre><code class="lang-python">a = torch.Tensor(2,2)print(a)b = a.numpy() #tensor 变为numpyprint(b)print(torch.from_numpy(b)) # numpy 变为tensor</code></pre><p>当然，如果你不需要实现任何花哨的东西，那么Keras会做得很好，因为你不会遇到任何TensorFlow障碍。 但如果你这样做，那么Pytorch可能会更顺畅。</p><h2 id="3-Training-models"><a href="#3-Training-models" class="headerlink" title="(3) Training models"></a>(3) Training models</h2><p>在Keras训练模型非常容易！ 只是一个简单的.fit()函数，你可以很轻松的进行训练。</p><pre><code class="lang-python">history = model.fit_generator(    generator=train_generator,    epochs=10,    validation_data=validation_generator)</code></pre><p>在Pytorch中训练一些模型需要一些步骤</p><ul><li>每一批次的训练开始时初始化梯度</li><li>在模型中运行前向传播</li><li>运行后向传播</li><li>计算损失和更新权重</li></ul><p>所以，就训练模型来说，PyTorch 较为繁琐。</p><pre><code class="lang-python">for epoch in range(2):  # loop over the dataset multiple times    running_loss = 0.0    for i, data in enumerate(trainloader, 0):        # Get the inputs; data is a list of [inputs, labels]        inputs, labels = data        # (1) Initialise gradients        optimizer.zero_grad()        # (2) Forward pass        outputs = net(inputs)        loss = criterion(outputs, labels)        # (3) Backward        loss.backward()        # (4) Compute the loss and update the weights        optimizer.step()</code></pre><h2 id="4-控制-CPU-vs-GPU-模式"><a href="#4-控制-CPU-vs-GPU-模式" class="headerlink" title="(4)控制 CPU vs GPU 模式"></a>(4)控制 CPU vs GPU 模式</h2><p>如果你已经安装了 tensorflow-gpu，则在 Keras 中能够使用 GPU 并且会默认完成。然后，如果你想要将某些运算转移至 CPU，则可以以单行方式完成。</p><pre><code class="lang-python">with tf.device(&#39;/cpu:0&#39;):    y = apply_non_max_suppression(x)</code></pre><p>但对于 PyTorch 来说，你必须显式地为每个 torch 张量和 numpy 变量启动 GPU。这样代码会比较混乱。并且如果你想在 CPU 和 GPU 之间来回移动以执行不同运算，则很容易出错。</p><p>例如，为了将之前的模型转移到 GPU 上运行，则需要以下步骤：</p><pre><code class="lang-python"># Get the GPU devicedevice = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)# Transfer the network to GPUnet.to(device)# Transfer the inputs and labels to GPUinputs, labels = data[0].to(device), data[1].to(device)</code></pre><p>因而，Keras 在简洁性和默认设置方面优于 PyTorch。</p><h2 id="选择-Keras-或-PyTorch-的一般性建议"><a href="#选择-Keras-或-PyTorch-的一般性建议" class="headerlink" title="选择 Keras 或 PyTorch 的一般性建议"></a>选择 Keras 或 PyTorch 的一般性建议</h2><p>作者通常建议初学者从 Keras 开始。Keras 绝对是理解和使用起来最简单的框架，能够很快地上手运行。你完全不需要担心 GPU 设置、处理抽象代码以及其他任何复杂的事情。你甚至可以在不接触任何 TensorFlow 单行代码的情况下，实现自定义层和损失函数。</p><p>但如果你开始深度了解到深度网络的更细粒度层面或者正在实现一些非标准的事情，则 PyTorch 是你的首选库。使用 PyTorch 需要进行一些额外操作，但这不会减缓你的进程。你依然能够快速实现、训练和测试网络，并享受简单调试带来的额外益处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度学习框架Keras与Pytorch的区别与优劣&lt;a href=&quot;https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="深度学习" scheme="https://www.vhcffh.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Keras" scheme="https://www.vhcffh.com/tags/Keras/"/>
    
      <category term="Pytorch" scheme="https://www.vhcffh.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>优化算法总结</title>
    <link href="https://www.vhcffh.com/2019/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://www.vhcffh.com/2019/优化算法总结/</id>
    <published>2019-07-04T13:16:52.000Z</published>
    <updated>2019-08-10T14:13:34.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AdaGrad-Adaptive-Gradient-自适应梯度"><a href="#AdaGrad-Adaptive-Gradient-自适应梯度" class="headerlink" title="AdaGrad(Adaptive Gradient)自适应梯度"></a>AdaGrad(Adaptive Gradient)自适应梯度</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><a id="more"></a><script type="math/tex; mode=display">\theta_{t+1} = \theta_t-\alpha\cdot g_t/\sqrt{\sum_{i=1}^tg_t^2} \ \ \ \ \ (\alpha=0.01)</script><p>随梯度的变化改变学习率</p><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><script type="math/tex; mode=display">v_t= \gamma(v_{t-1})+(1-\gamma)g_t^2 \ \ \ \ \ (\gamma=0.9)</script><script type="math/tex; mode=display">\theta_{t} = \theta_{t-1}-\alpha* g_t/(\sqrt v_t + \varepsilon) \ \ \ \ \ (\alpha=0.001,\varepsilon=10^{-8})</script><p>结合梯度平方的指数移动平均数来调节学习率的变化</p><p>克服AdaGrad梯度急剧减小的问题</p><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><script type="math/tex; mode=display">g_t = \nabla_\theta J(\theta_{t-1})</script><script type="math/tex; mode=display">m_t = \beta_1m_{t-1}+(1-\beta_1)g_t \ \ \ \ \ (\beta_1=0.9,m_0=0)</script><script type="math/tex; mode=display">v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2 \ \ \ \ \ (\beta_2=0.999,v_0=0)</script><script type="math/tex; mode=display">\hat m_t = m_t/(1-\beta_1^t)</script><script type="math/tex; mode=display">\hat v_t = v_t/(1-\beta_2^t)</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1}-\alpha * \hat m_t/(\hat v_t + \varepsilon) \ \ \ \ \ (\alpha=0.001,\varepsilon=10^{-8})</script><p>对梯度的一阶矩估计（First Moment Estimation，即梯度的均值）和二阶矩估计（Second</p><p>Moment Estimation，即梯度的未中心化的方差）进行综合考虑，计算出更新步长。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AdaGrad-Adaptive-Gradient-自适应梯度&quot;&gt;&lt;a href=&quot;#AdaGrad-Adaptive-Gradient-自适应梯度&quot; class=&quot;headerlink&quot; title=&quot;AdaGrad(Adaptive Gradient)自适应梯度&quot;&gt;&lt;/a&gt;AdaGrad(Adaptive Gradient)自适应梯度&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
g_t = \nabla_\theta J(\theta_{t-1})&lt;/script&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://www.vhcffh.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="AdaGrad" scheme="https://www.vhcffh.com/tags/AdaGrad/"/>
    
      <category term="RMSProp" scheme="https://www.vhcffh.com/tags/RMSProp/"/>
    
      <category term="Adam" scheme="https://www.vhcffh.com/tags/Adam/"/>
    
  </entry>
  
  <entry>
    <title>Python中遇到的问题</title>
    <link href="https://www.vhcffh.com/2019/python%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.vhcffh.com/2019/python中遇到的问题/</id>
    <published>2019-05-31T00:35:00.000Z</published>
    <updated>2019-08-10T10:27:56.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-列表的初始化"><a href="#1-列表的初始化" class="headerlink" title="1.列表的初始化"></a>1.列表的初始化</h3><p>当初始化一个n×n的列表时不能使用如下方法，</p><pre><code class="lang-python">In [1]: l=[[0]*3]*3 #如此初始化会导致其它行仅是第一行的引用而不是copyIn [2]: lOut[2]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]In [3]: l[0][0]=1 #改变其中一行的某个元素In [4]: lOut[4]: [[1, 0, 0], [1, 0, 0], [1, 0, 0]] #其他行跟着改变</code></pre><p>正确的方法应该如下</p><pre><code class="lang-python">In [5]: l=[[0 for _ in range(3)] for _ in range(3)] #或者l=[[0]*3 for _ in range(3)]In [6]: lOut[6]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]In [7]: l[0][0]=1In [8]: lOut[8]: [[1, 0, 0], [0, 0, 0], [0, 0, 0]]</code></pre><h3 id="2-a-is-b与a-b-的区别"><a href="#2-a-is-b与a-b-的区别" class="headerlink" title="2.a is b与a==b 的区别"></a>2.a is b与a==b 的区别</h3><pre><code>a=&#39;vhcffh.com&#39;b=&#39;vhcffh.com&#39;a==b # True,a和b对应实例的内容是相同的a is b # False,a和b指向不同的实例b=aa is b # True,a和b指向同一个实例</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-列表的初始化&quot;&gt;&lt;a href=&quot;#1-列表的初始化&quot; class=&quot;headerlink&quot; title=&quot;1.列表的初始化&quot;&gt;&lt;/a&gt;1.列表的初始化&lt;/h3&gt;&lt;p&gt;当初始化一个n×n的列表时不能使用如下方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;l
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python常用方法</title>
    <link href="https://www.vhcffh.com/2019/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.vhcffh.com/2019/python常用方法/</id>
    <published>2019-05-29T21:26:00.000Z</published>
    <updated>2019-08-10T10:28:18.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-sorted排序"><a href="#1-sorted排序" class="headerlink" title="1.sorted排序"></a>1.sorted排序</h3><pre><code class="lang-python">sorted(iterable[, cmp[, key[, reverse]]])</code></pre><p>参数说明：</p><ul><li>iterable — 可迭代对象。</li><li>cmp — 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li><li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse — 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-sorted排序&quot;&gt;&lt;a href=&quot;#1-sorted排序&quot; class=&quot;headerlink&quot; title=&quot;1.sorted排序&quot;&gt;&lt;/a&gt;1.sorted排序&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;sorted(ite
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.vhcffh.com/2019/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.vhcffh.com/2019/linux常用命令/</id>
    <published>2019-05-20T21:22:00.000Z</published>
    <updated>2019-08-10T10:27:34.127Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中的一些常用命令,tar<br><a id="more"></a></p><h2 id="1-tar解压打包相关"><a href="#1-tar解压打包相关" class="headerlink" title="1.tar解压打包相关"></a>1.tar解压打包相关</h2><pre><code class="lang-shell">tar -cvf log.tar log2019.log    #仅打包，不压缩tar -zcvf log.tar.gz log2019.log   #打包后，以 gzip 压缩tar -jcvf log.tar.bz2 log2019.log  #打包后，以 bzip2 压缩tar -ztvf log.tar.gz #gzip查阅tar -jtvf log.tar.gz #bzip2查阅tar -zxvf log.tar.gz #gzip解压tar -jxvf log.tar.gz #bzip2解压unzip log.zip -d dirname #zip解压到dirname目录</code></pre><p>补充</p><p>c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出 </p><h2 id="2-wget设置代理"><a href="#2-wget设置代理" class="headerlink" title="2.wget设置代理"></a>2.wget设置代理</h2><h3 id="2-1环境变量中设置"><a href="#2-1环境变量中设置" class="headerlink" title="2.1环境变量中设置"></a>2.1环境变量中设置</h3><pre><code class="lang-shell">export http_proxy=http://127.0.0.1:8087</code></pre><h3 id="2-2使用配置文件"><a href="#2-2使用配置文件" class="headerlink" title="2.2使用配置文件"></a>2.2使用配置文件</h3><pre><code class="lang-shell"># cp /etc/wgetrc ~/.wgetrc# vim ~/.wgetrc# You can set the default proxies for Wget to use for http, https, and ftp.# They will override the value in the environment.https_proxy = http://127.0.0.1:8087/http_proxy = http://127.0.0.1:8087/ftp_proxy = http://127.0.0.1:8087/# If you do not want to use proxy at all, set this to off.use_proxy = on</code></pre><h2 id="3-ps相关命令"><a href="#3-ps相关命令" class="headerlink" title="3.ps相关命令"></a>3.ps相关命令</h2><pre><code class="lang-shell">ps -ef # 查看进程信息和执行的命令</code></pre><h2 id="4-用户文件管理相关"><a href="#4-用户文件管理相关" class="headerlink" title="4.用户文件管理相关"></a>4.用户文件管理相关</h2><h3 id="4-1Linux系统用户账号的管理"><a href="#4-1Linux系统用户账号的管理" class="headerlink" title="4.1Linux系统用户账号的管理"></a>4.1Linux系统用户账号的管理</h3><h4 id="4-1-1添加新的用户账号"><a href="#4-1-1添加新的用户账号" class="headerlink" title="4.1.1添加新的用户账号"></a>4.1.1添加新的用户账号</h4><pre><code class="lang-shell">useradd [-d dirname] username# [-d dirname]指定用户主目录</code></pre><h4 id="4-1-2删除帐号"><a href="#4-1-2删除帐号" class="headerlink" title="4.1.2删除帐号"></a>4.1.2删除帐号</h4><pre><code class="lang-shell">userdel [-r] username# [-R]把用户的主目录一起删除</code></pre><h4 id="4-1-3修改帐号"><a href="#4-1-3修改帐号" class="headerlink" title="4.1.3修改帐号"></a>4.1.3修改帐号</h4><pre><code class="lang-shell">usermod [] username</code></pre><h4 id="4-1-4用户密码管理"><a href="#4-1-4用户密码管理" class="headerlink" title="4.1.4用户密码管理"></a>4.1.4用户密码管理</h4><pre><code class="lang-shell">passwd [-I][-u][-d][-f] username# [-I]锁定密码，即禁用账号。# [-u]密码解锁。# [-d]使账号无密码。# [-f]强迫用户下次登录时修改密码。</code></pre><h3 id="4-2Linux系统用户组的管理"><a href="#4-2Linux系统用户组的管理" class="headerlink" title="4.2Linux系统用户组的管理"></a>4.2Linux系统用户组的管理</h3><h4 id="4-2-1增加一个新的用户组"><a href="#4-2-1增加一个新的用户组" class="headerlink" title="4.2.1增加一个新的用户组"></a>4.2.1增加一个新的用户组</h4><pre><code class="lang-shell">groupadd [-g GID] username# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-2删除一个已有的用户组"><a href="#4-2-2删除一个已有的用户组" class="headerlink" title="4.2.2删除一个已有的用户组"></a>4.2.2删除一个已有的用户组</h4><pre><code class="lang-shell">groupdel groupname</code></pre><h4 id="4-2-3修改用户组的属性"><a href="#4-2-3修改用户组的属性" class="headerlink" title="4.2.3修改用户组的属性"></a>4.2.3修改用户组的属性</h4><pre><code class="lang-shell">groupmod [-g GID] groupname# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-4更改用户组"><a href="#4-2-4更改用户组" class="headerlink" title="4.2.4更改用户组"></a>4.2.4更改用户组</h4><p><strong>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。</strong></p><pre><code class="lang-shell">newgrp root</code></pre><h3 id="4-3Linux文件用户属性修改"><a href="#4-3Linux文件用户属性修改" class="headerlink" title="4.3Linux文件用户属性修改"></a>4.3Linux文件用户属性修改</h3><pre><code class="lang-shell">chown [-R] user_name filename_OR_dirname  # 更改文件或目录的所有者chgrp [-R] group_name filename_OR_dirname  # 更改文件或目录所在组# [-R]参数递归更改目录下所有文件的用户属性</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">http://man.linuxde.net/tar</a></p><p>2.<a href="https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html" target="_blank" rel="noopener">https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html</a></p><p>3.<a href="https://www.cnblogs.com/52php/p/5677628.html" target="_blank" rel="noopener">https://www.cnblogs.com/52php/p/5677628.html</a></p><p>4.<a href="https://www.jb51.net/LINUXjishu/43356.html" target="_blank" rel="noopener">https://www.jb51.net/LINUXjishu/43356.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux中的一些常用命令,tar&lt;br&gt;
    
    </summary>
    
      <category term="软件使用" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Linux/"/>
    
    
      <category term="linux" scheme="https://www.vhcffh.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>UML图介绍</title>
    <link href="https://www.vhcffh.com/2019/UML%E5%9B%BE%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.vhcffh.com/2019/UML图介绍/</id>
    <published>2019-04-21T13:02:47.000Z</published>
    <updated>2019-08-10T13:17:04.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用例视图"><a href="#1-用例视图" class="headerlink" title="1.用例视图"></a>1.用例视图</h2><h2 id="1-1用例图"><a href="#1-1用例图" class="headerlink" title="1.1用例图"></a>1.1用例图</h2><p>描述角色以及角色与用例之间的连接关系。说明的是谁要使用系统，以及他们使用该系统可以做些什么。</p><h2 id="2设计视图"><a href="#2设计视图" class="headerlink" title="2设计视图"></a>2设计视图</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p>根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p><p>类图是描述系统中的类，以及各个类之间的关系的静态视图。能够让我们在正确编写代码以前对系统有一个全面的认识。类图是一种模型类型，确切的说，是一种静态模型类型。</p><h3 id="2-2对象图"><a href="#2-2对象图" class="headerlink" title="2.2对象图"></a>2.2对象图</h3><p>描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。</p><p>与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。</p><h2 id="3-进程视图"><a href="#3-进程视图" class="headerlink" title="3.进程视图"></a>3.进程视图</h2><h3 id="3-1序列图（顺序图）"><a href="#3-1序列图（顺序图）" class="headerlink" title="3.1序列图（顺序图）"></a>3.1序列图（顺序图）</h3><p>交互图的一种，描述了对象之间消息发送的先后顺序，强调时间顺序。</p><p>序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。</p><h3 id="3-2协作图"><a href="#3-2协作图" class="headerlink" title="3.2协作图"></a>3.2协作图</h3><p>交互图的一种，描述了收发消息的对象的组织关系，强调对象之间的合作关系。时序图按照时间顺序布图，而写作图按照空间结构布图</p><p>和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择协作图；这两种图合称为交互图。</p><h3 id="3-3状态图"><a href="#3-3状态图" class="headerlink" title="3.3状态图"></a>3.3状态图</h3><p>是一种由状态、变迁、事件和活动组成的状态机，用来描述类的对象所有可能的状态以及时间发生时状态的转移条件。</p><p>描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。状态图是对类图的补充。</p><h3 id="3-4活动图"><a href="#3-4活动图" class="headerlink" title="3.4活动图"></a>3.4活动图</h3><p>是状态图的一种特殊情况，这些状态大都处于活动状态。本质是一种流程图，它描述了活动到活动的控制流。</p><p>描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能</p><h2 id="4-实现视图"><a href="#4-实现视图" class="headerlink" title="4.实现视图"></a>4.实现视图</h2><h3 id="4-1构件图-（组件图）"><a href="#4-1构件图-（组件图）" class="headerlink" title="4.1构件图 （组件图）"></a>4.1构件图 （组件图）</h3><p>描述代码构件的物理结构以及各种构建之间的依赖关系。用来建模软件的组件及其相互之间的关系，这些图由构件标记符和构件之间的关系构成。在组件图中，构件时软件单个组成部分，它可以是一个文件，产品、可执行文件和脚本等。</p><h2 id="5-拓扑视图"><a href="#5-拓扑视图" class="headerlink" title="5.拓扑视图"></a>5.拓扑视图</h2><h3 id="5-1部署图"><a href="#5-1部署图" class="headerlink" title="5.1部署图"></a>5.1部署图</h3><p>是用来建模系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。部署图的使用者是开发人员、系统集成人员和测试人员。</p><h2 id="6-软件设计及过程"><a href="#6-软件设计及过程" class="headerlink" title="6.软件设计及过程"></a>6.软件设计及过程</h2><p>在需求阶段：采用用例图来描述需求<br>在分析阶段：采用类图来描述静态结构<br>在设计阶段：采用类图、包图对类的接口进行设计<br>在实现阶段：将类用某个面向对象的语言实现<br>在集成与交付阶段：构件图、包图、部署图<br>在测试阶段：单元测试使用类图和类的规格说明书<br>                     集成测试阶段使用类图、包图、构件图和合作图<br>                     系统测试使用用例图来测试系统功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-用例视图&quot;&gt;&lt;a href=&quot;#1-用例视图&quot; class=&quot;headerlink&quot; title=&quot;1.用例视图&quot;&gt;&lt;/a&gt;1.用例视图&lt;/h2&gt;&lt;h2 id=&quot;1-1用例图&quot;&gt;&lt;a href=&quot;#1-1用例图&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="知识介绍" scheme="https://www.vhcffh.com/categories/%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="UML" scheme="https://www.vhcffh.com/tags/UML/"/>
    
      <category term="软件设计" scheme="https://www.vhcffh.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>边缘计算系统中延迟敏感任务的成本有效调度</title>
    <link href="https://www.vhcffh.com/2019/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BB%B6%E8%BF%9F%E6%95%8F%E6%84%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%88%90%E6%9C%AC%E6%9C%89%E6%95%88%E8%B0%83%E5%BA%A6/"/>
    <id>https://www.vhcffh.com/2019/边缘计算系统中延迟敏感任务的成本有效调度/</id>
    <published>2019-04-05T12:57:47.000Z</published>
    <updated>2019-08-10T13:00:44.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>边缘计算作为一种新兴的计算模型，可以将具有有限计算资源和能量的物联网（IoT）设备的延迟敏感计算任务卸载到边缘云。在边缘计算系统中，多个服务器放置在IoT设备附近的网络边缘上以处理卸载的任务。边缘计算系统的一个关键问题是如何在完成卸载任务的同时降低系统成本。在本文中，我们研究任务调度问题，以降低边缘计算系统的成本。我们将任务调度问题建模为优化问题，其目标是在满足所有任务的延迟要求的同时最小化系统成本。然后，我们证明了所提出的优化问题是NP难的。为了有效地解决这个优化问题，我们提出了一种任务调度算法，称为两阶段任务调度成本优化（TTSCO）。我们通过与最优解进行比较来验证算法的有效性。结果表明，对于我们使用的95％的数据集，近似比率小于1.2。性能评估表明，该算法能够有效降低边缘计算系统的成本，同时满足所有任务的延迟要求。索引术语 - 边缘计算;任务调度;延迟敏感的任务;成本效益;</p><h3 id="云计算与边缘计算的区别和边缘计算要解决的问题"><a href="#云计算与边缘计算的区别和边缘计算要解决的问题" class="headerlink" title="云计算与边缘计算的区别和边缘计算要解决的问题"></a>云计算与边缘计算的区别和边缘计算要解决的问题</h3><p>随着物联网技术的发展，延迟敏感应用（例如，健康监测[1]，基于位置的增强现实游戏）的数量正在迅速增加[2]。由于物联网设备的计算资源和能量有限，因此应将许多处理繁重的任务卸载到远程服务器进行处理。具有强大计算能力的云计算被认为是处理卸载任务的潜在方式。但是，由于传统云和物联网设备之间的距离较远，将大量任务发送到传统云进行处理会导致响应时间过长，网络拥塞严重。为了解决这个问题，最近提出边缘计算作为一种有前景的计算模型[3]，[4]。边缘计算提供附加的计算基础设施层，其由网络边缘处的一些服务器（即，基站）组成。对于从物联网设备卸载的计算任务，边缘计算提供计算服务并将结果返回给设备。这样，卸载任务的传输延迟和核心网的流量负载将大大降低。</p><h3 id="在边缘计算中的任务调度问题"><a href="#在边缘计算中的任务调度问题" class="headerlink" title="在边缘计算中的任务调度问题"></a>在边缘计算中的任务调度问题</h3><p>设备如何进行任务卸载决策<br>降低传输或计算任务所产生的系统成本<br>边缘计算系统中任务调度问题的成本优化<br>在边缘计算中，任务调度问题已成为研究的热门话题[9] - [18]。为了减少由任务计算引起的能耗，物联网设备会将计算任务卸载到边缘服务器。但是，卸载任务会消耗额外的能量来将任务传输到边缘服务器，卸载任务的完成时间也会增加。在这种情况下，一些工作研究了设备如何进行任务卸载决策[9] - [12]。另外，当计算任务被调度到不同的边缘服务器时，传输和计算的成本也不同。因此，一些工作旨在降低传输或计算任务所产生的系统成本[13] - [18]。但是，这些工作很少考虑边缘服务器生成的成本。在非高峰时间（例如，在夜间）降低由服务器引起的系统成本的问题在很大程度上未被探索[5]。</p><h3 id="本文研究的问题"><a href="#本文研究的问题" class="headerlink" title="本文研究的问题"></a>本文研究的问题</h3><p>边缘计算系统中任务调度问题的成本优化<br>在本文中，我们研究边缘计算系统中任务调度问题的成本优化。目标是在满足所有任务的QoS要求的同时最小化边缘计算系统的成本。我们为延迟敏感的输入任务开发了一个任务调度模型。然后，我们制定成本优化问题并证明该优化问题为NP-Hard。接下来，我们提出了一种近似算法来解决这个优化问题，称为两阶段任务调度成本优化（TTSCO），并对TTSCO算法进行分析。最后，仿真结果验证了算法的准确性和性能。</p><p>边缘计算作为一种新兴的计算模型，可以将具有有限计算资源和能量的物联网（IoT）设备的延迟敏感计算任务卸载到边缘云。在边缘计算系统中，多个服务器放置在IoT设备附近的网络边缘上以处理卸载的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;边缘计算作为一种新兴的计算模型，可以将具有有限计算资源和能量的物联网（IoT）设备的延迟敏感计算任务卸载到边缘云。在边缘计算系统中，多个服务
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://www.vhcffh.com/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="边缘计算" scheme="https://www.vhcffh.com/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>java注解的使用</title>
    <link href="https://www.vhcffh.com/2019/java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.vhcffh.com/2019/java注解的使用/</id>
    <published>2019-03-20T12:38:28.000Z</published>
    <updated>2019-08-10T13:01:19.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-三种标准注解"><a href="#1-三种标准注解" class="headerlink" title="1.三种标准注解"></a>1.三种标准注解</h3><ul><li><p>@Override,表示当前的方法定义覆盖了父类中的方法。必须要有相同的方法签名即(方法名，参数类型，参数顺序，参数个数)都一样。否则在编译过程中发出错误提示。</p></li><li><p>@Deprecated,对不应该再使用的方法添加注解，当使用这个方法的时候，会在编译时候显示提示信息。</p></li><li><p>@SuppressWarnings,关闭不当的编译器报警信息</p></li></ul><h3 id="2-四种元注解："><a href="#2-四种元注解：" class="headerlink" title="2.四种元注解："></a>2.四种元注解：</h3><ul><li><p>@Target,表示该注解可以用什么地方。如CONSTRUCTOR,构造器声明；FIELD,域声明;METHOD,方法声明;TYPE，类，接口或enum声明</p></li><li><p>@Retention,表示需要在什么级别保存该注解信息。如SOURCE,注解将被编译器丢弃；CLASS,注解在class文件可用，但会被VM丢弃RUNTIME,VM将在运行期间也保留注解，可以使用反射机制读取注解信息</p></li><li><p>@Documented,将此注解包含到Javadoc中。</p></li><li><p>@Inherited,允许子类继承父类的注解。</p></li></ul><p>Java 7开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生</li><li><p>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</p></li><li><p>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-三种标准注解&quot;&gt;&lt;a href=&quot;#1-三种标准注解&quot; class=&quot;headerlink&quot; title=&quot;1.三种标准注解&quot;&gt;&lt;/a&gt;1.三种标准注解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;@Override,表示当前的方法定义覆盖了父类中的方法。必须要有相同的方
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="注解" scheme="https://www.vhcffh.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化开源项目</title>
    <link href="https://www.vhcffh.com/2019/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.vhcffh.com/2019/数据可视化开源项目/</id>
    <published>2019-03-10T09:34:36.000Z</published>
    <updated>2019-08-10T13:01:03.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-D3"><a href="#1-D3" class="headerlink" title="1.D3"></a>1.<a href="https://d3js.org/" target="_blank" rel="noopener">D3</a></h3><p>github地址:<a href="https://github.com/d3/d3" target="_blank" rel="noopener">https://github.com/d3/d3</a></p><p><img src="/images/2019/8_10_d3.png" alt="d3"></p><h3 id="2-chartjs"><a href="#2-chartjs" class="headerlink" title="2.chartjs"></a>2.<a href="https://www.chartjs.org" target="_blank" rel="noopener">chartjs</a></h3><p>github地址:<a href="https://github.com/chartjs/Chart.js" target="_blank" rel="noopener">https://github.com/chartjs/Chart.js</a></p><p><img src="/images/2019/8_10_charts.png" alt="Screenshot_20190810_184821"></p><h3 id="3-leafletjs"><a href="#3-leafletjs" class="headerlink" title="3.leafletjs"></a>3.<a href="https://leafletjs.com/examples.html" target="_blank" rel="noopener">leafletjs</a></h3><p>github地址:<a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="noopener">https://github.com/Leaflet/Leaflet</a></p><p>主要是移动到地图的支持</p><p><img src="/images/2019/8_10_leafletjs.png" alt="Screenshot_20190810_185124"></p><h3 id="4-echarts"><a href="#4-echarts" class="headerlink" title="4.echarts"></a>4.<a href="https://echarts.baidu.com/examples/#chart-type-line" target="_blank" rel="noopener">echarts</a></h3><p>百度家的</p><p>github地址:<a href="https://github.com/ecomfe/echarts" target="_blank" rel="noopener">https://github.com/ecomfe/echarts</a></p><p><img src="/images/2019/8_10_echarts.png" alt="Screenshot_20190810_185457"></p><h3 id="5-Chartist-js"><a href="#5-Chartist-js" class="headerlink" title="5.Chartist-js"></a>5.<a href="https://gionkunz.github.io/chartist-js/examples.html" target="_blank" rel="noopener">Chartist-js</a></h3><h3 id="6-sigmajs"><a href="#6-sigmajs" class="headerlink" title="6.sigmajs"></a>6.<a href="http://sigmajs.org/" target="_blank" rel="noopener">sigmajs</a></h3><h3 id="7-metricsgraphicsjs"><a href="#7-metricsgraphicsjs" class="headerlink" title="7.metricsgraphicsjs"></a>7.<a href="https://metricsgraphicsjs.org/examples.htm" target="_blank" rel="noopener">metricsgraphicsjs</a></h3><h3 id="8-DC-js-开源-D3"><a href="#8-DC-js-开源-D3" class="headerlink" title="8.DC.js,开源(D3)"></a>8.<a href="https://dc-js.github.io/dc.js/" target="_blank" rel="noopener">DC.js,开源(D3)</a></h3><h3 id="9-阿里数据可视化"><a href="#9-阿里数据可视化" class="headerlink" title="9.阿里数据可视化"></a>9.<a href="https://antv.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">阿里数据可视化</a></h3><p><a href="https://antv.alipay.com/zh-cn/g2/3.x/demo/index.html" target="_blank" rel="noopener">G2</a>,<a href="https://antv.alipay.com/zh-cn/g6/2.x/demo/index.html" target="_blank" rel="noopener">G6</a>,<a href="https://antv.alipay.com/zh-cn/f2/3.x/demo/index.html" target="_blank" rel="noopener">F2</a>,<a href="https://antv.alipay.com/zh-cn/l7/1.x/demo/index.html" target="_blank" rel="noopener">L7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-D3&quot;&gt;&lt;a href=&quot;#1-D3&quot; class=&quot;headerlink&quot; title=&quot;1.D3&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;https://d3js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D3&lt;/a&gt;&lt;/h3&gt;&lt;p
      
    
    </summary>
    
      <category term="大数据" scheme="https://www.vhcffh.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="数据可视化" scheme="https://www.vhcffh.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>简单的iptables配置过程</title>
    <link href="https://www.vhcffh.com/2018/%E7%AE%80%E5%8D%95%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>https://www.vhcffh.com/2018/简单的iptables配置过程/</id>
    <published>2018-10-19T02:01:00.000Z</published>
    <updated>2019-08-10T10:27:27.607Z</updated>
    
    <content type="html"><![CDATA[<p>简单的记一下iptables的配置过程，以后用到了就不用再google了<br>总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则</p><h2 id="iptables配置过程"><a href="#iptables配置过程" class="headerlink" title="iptables配置过程"></a>iptables配置过程</h2><h3 id="1-清除规则"><a href="#1-清除规则" class="headerlink" title="1.清除规则:"></a>1.清除规则:</h3><p>清楚旧的规则<br>iptables -F 清除预设表filter中的所有规则链的规则<br>iptables -X 清除预设表filter中使用者自定链中的规则</p><h3 id="2-设定预设规则"><a href="#2-设定预设规则" class="headerlink" title="2.设定预设规则"></a>2.设定预设规则</h3><p>默认情况下对各种包的处理方式<br>iptables -p INPUT DROP<br>iptables -p OUTPUT ACCEPT<br>iptables -p FORWARD DROP</p><h3 id="3-添加用户自定义规则"><a href="#3-添加用户自定义规则" class="headerlink" title="3.添加用户自定义规则"></a>3.添加用户自定义规则</h3><p>对于特定端口协议的包的规则进行设置<br>iptables -A INPUT -p tcp —dport 22 -j ACCEPT<br>-A:表示添加规则到INPUT(OUTPUT,FORWARD)链<br>-p:表示tcp(udp)协议<br>—dport(—sport):目的端口号(源端口号)<br>-j():添加规则为接受</p><h3 id="4-保存规则"><a href="#4-保存规则" class="headerlink" title="4.保存规则"></a>4.保存规则</h3><p>不保存的话重启后就没有了<br>service iptables save</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html" target="_blank" rel="noopener">http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的记一下iptables的配置过程，以后用到了就不用再google了&lt;br&gt;总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则&lt;/p&gt;
&lt;h2 id=&quot;iptables配置过程&quot;&gt;&lt;a href=&quot;#iptables配置过程&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="软件使用" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Linux/"/>
    
    
      <category term="服务器" scheme="https://www.vhcffh.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="系统" scheme="https://www.vhcffh.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>socket网络编程</title>
    <link href="https://www.vhcffh.com/2018/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.vhcffh.com/2018/socket网络编程/</id>
    <published>2018-10-18T02:01:00.000Z</published>
    <updated>2019-08-10T10:25:43.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h3><pre><code class="lang-c">int inet_aton(const char *cp, struct in_addr *inp);</code></pre><p>转换网络主机地址为二进制数值并存储与第二个参数中<br>函数返回0表示主机地址无效，非0表示主机地址有效<br>转化完后需要调用htons或htonl函数才能将主机字节序转换为网络字节序用于网络传输</p><pre><code class="lang-c">char *inet_ntoa(struct in_addr in);</code></pre><p>转换网络字节序为标准的ASCII以点分开的地址，函数返回字符串指针<br>该字符串空间为静态分配，第二次调用时会覆盖第一次的内容</p><pre><code class="lang-c">in_addr_t inet_addr(const char *cp);</code></pre><p>转换网络主机地址为网络字节序二进制值<br>参数无效，返回-1(INADDR_NONE)<br>注意：转换255.255.255.255时也返回-1</p><pre><code class="lang-c">int inet_pton(int af, const char *src, void *dst);</code></pre><p>转换字符串到网络地址，af是地址簇，<em>src是来源地址，</em> dst接收转换后的数据。</p><pre><code class="lang-c">const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);</code></pre><p>转换网络字节序二进制值到ASCII类型的地址，参数的作用和inet_pton相同，<br>socklen_t cnt指所指向缓存区dst的大小，避免溢出，如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。</p><pre><code class="lang-c">int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);</code></pre><p>int maxfdp 指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。<br>struct fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄。监视这些文件描述符的读变化</p><pre><code class="lang-c">int setsockopt(SOCKET s,int level,int optname,const char* optval,int optlen);</code></pre><p>s(套接字): 指向一个打开的套接口描述字<br>level:(级别)： 指定选项代码的类型。<br>SOL_SOCKET: 基本套接口<br>IPPROTO_IP: IPv4套接口<br>IPPROTO_IPV6: IPv6套接口<br>IPPROTO_TCP: TCP套接口<br>optname(选项名)： 选项名称<br>optval(选项值): 是一个指向变量的指针 类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }<br>optlen(选项长度) ：optval 的大小</p><pre><code class="lang-c">int PASCAL FAR recvfrom( SOCKET s, char FAR* buf, int len, int flags,struct sockaddr FAR* from, int FAR* fromlen);</code></pre><p>s：标识一个已连接套接口的描述字。<br>buf：接收数据缓冲区。<br>len：缓冲区长度。<br>flags：调用操作方式。<br>from：（可选）指针，指向装有源地址的缓冲区。<br>fromlen：（可选）指针，指向from缓冲区长度值。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://blog.csdn.net/zyy617532750/article/details/58595700" target="_blank" rel="noopener">https://blog.csdn.net/zyy617532750/article/details/58595700</a><br>2.<a href="https://www.cnblogs.com/zhoudingcocng/p/6209961.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoudingcocng/p/6209961.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;socket网络编程&quot;&gt;&lt;a href=&quot;#socket网络编程&quot; class=&quot;headerlink&quot; title=&quot;socket网络编程&quot;&gt;&lt;/a&gt;socket网络编程&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;int inet_aton(c
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C语言" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="socket" scheme="https://www.vhcffh.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机基础知识</title>
    <link href="https://www.vhcffh.com/2018/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.vhcffh.com/2018/形式语言与自动机基础知识/</id>
    <published>2018-09-22T02:01:00.000Z</published>
    <updated>2019-08-10T10:26:36.427Z</updated>
    
    <content type="html"><![CDATA[<p>形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识</p><h2 id="1-集合及其运算"><a href="#1-集合及其运算" class="headerlink" title="1.集合及其运算"></a>1.集合及其运算</h2><h3 id="1-1子集和真子集"><a href="#1-1子集和真子集" class="headerlink" title="1.1子集和真子集"></a>1.1子集和真子集</h3><p>$A$子集：$A \subseteq B​$或$B \subseteq A​$<br>$A​$是$B​$的真子集：$A \subset B​$或$B \subset A​$<br>$x​$是$A​$的一个元素：$x \in A​$<br>$x​$不是$A​$的一个元素：$x \notin A​$</p><h3 id="1-2集合的交并差补"><a href="#1-2集合的交并差补" class="headerlink" title="1.2集合的交并差补"></a>1.2集合的交并差补</h3><p>$A$和$B$的并集：$A\cup B={x|x\in A或x\in B}$<br>$A$和$B$的交集：$A\cap B={x|x\in A且x\in B}$<br>$A$和$B$的差集：$A - B={x|x\in A且x\notin B}$<br>若$B\subseteq A$我们也称$A−B$为$B$的（关于$A$）补,记作：$\overline B(A)​$</p><h3 id="1-3集合的并的推广"><a href="#1-3集合的并的推广" class="headerlink" title="1.3集合的并的推广"></a>1.3集合的并的推广</h3><p>设$I​$是某些标号的集合我们将$\displaystyle \bigcup_{i\in I}A_i={x|存在i\in I,使得x\in A_i}​$</p><h3 id="1-4A的幂集"><a href="#1-4A的幂集" class="headerlink" title="1.4A的幂集"></a>1.4A的幂集</h3><p>$A$的所有子集的集合，记作$2^A={B|B\subseteq A}​$</p><h3 id="1-5笛卡尔乘积"><a href="#1-5笛卡尔乘积" class="headerlink" title="1.5笛卡尔乘积"></a>1.5笛卡尔乘积</h3><p>$A\times B={(a,b)|a\in A且b\in B}$</p><h3 id="1-6集合之间的关系"><a href="#1-6集合之间的关系" class="headerlink" title="1.6集合之间的关系"></a>1.6集合之间的关系</h3><p>由$A$到$B$的关系是$A×B$的任何子集。若$A=B$，则称为$A$上的关系。若$R$为$A$到$B$的关系，当$(a,b)$在$R$内时，可写成$aRb​$</p><h3 id="1-7集合关系的性质"><a href="#1-7集合关系的性质" class="headerlink" title="1.7集合关系的性质"></a>1.7集合关系的性质</h3><p>设$R$是集合$A$上的关系，则有<br>（1）若对$A$中的任一元素$a$，都有$aRa$，则称$R$是<strong>自反的</strong>；<br>（2）若对$A$中的任何元素$a,b$，从$aRb$能够推到出$bRa$，则称$R$是<strong>对称的</strong>；<br>（3）若$a,b,c$是$A$中的元素，从$aRb$和$bRc$能够推出$aRc$，则称$R$是<strong>传递的</strong>；<br>若关系$R​$同时是自反的，对称的和传递的，则称之为<strong>等价关系</strong>。<br>2018-09-22 15:28:12</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.《形式语言与自动机》陈有祺编著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识&lt;/p&gt;
&lt;h2 id=&quot;1-集合及其运算&quot;&gt;&lt;a href=&quot;#1-集合及其运算&quot; class=&quot;headerlink&quot; title=&quot;1.集合及其运算&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="数学" scheme="https://www.vhcffh.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="基础知识" scheme="https://www.vhcffh.com/categories/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合" scheme="https://www.vhcffh.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>梯度旋度和散度</title>
    <link href="https://www.vhcffh.com/2018/%E6%A2%AF%E5%BA%A6%E6%97%8B%E5%BA%A6%E5%92%8C%E6%95%A3%E5%BA%A6/"/>
    <id>https://www.vhcffh.com/2018/梯度旋度和散度/</id>
    <published>2018-09-08T02:01:00.000Z</published>
    <updated>2019-08-10T10:27:09.777Z</updated>
    
    <content type="html"><![CDATA[<p>有关梯度旋度和散度的定义和计算,记录一下</p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><h3 id="1-1梯度"><a href="#1-1梯度" class="headerlink" title="1.1梯度"></a>1.1梯度</h3><p>设函数$u=f(x,y,z)$在空间区域\(G\)内具有一阶连续偏导数,其中点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">\left\{  \frac {\partial f}{\partial x},  \frac {\partial f}{\partial y},  \frac {\partial f}{\partial z}\right\}=\frac {\partial f}{\partial x}\vec i+\frac {\partial f}{\partial y}\vec j+\frac {\partial f}{\partial z}\vec k</script><p>为函数$u=f(x,y,z)$在点$P(x,y,z)​$的<strong>梯度</strong><br>记为$gradf(x,y,z)​$或$\nabla f(x,y,z)$</p><p>(注:</p><script type="math/tex; mode=display">\nabla = \frac {\partial}{\partial x}\vec i+\frac {\partial}{\partial y}\vec j+\frac {\partial}{\partial z}\vec k</script><p>称为三维的向量微分算子)</p><h3 id="1-2旋度"><a href="#1-2旋度" class="headerlink" title="1.2旋度"></a>1.2旋度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}​$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">  \begin{vmatrix}  \vec i & \vec j & \vec k \\  \frac {\partial}{\partial x} & \frac {\partial}{\partial y} & \frac {\partial}{\partial z} \\  v_x & v_y & v_z \\  \end{vmatrix} =   (\frac {\partial v_z}{\partial y} - \frac {\partial v_y}{\partial z})\vec i+  (\frac {\partial v_x}{\partial z} - \frac {\partial v_z}{\partial x})\vec j+  (\frac {\partial v_y}{\partial x} - \frac {\partial v_x}{\partial y})\vec k</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>旋度</strong><br>记为$curl\;v$或者$\nabla \times v$</p><h3 id="1-3散度"><a href="#1-3散度" class="headerlink" title="1.3散度"></a>1.3散度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G​$</p><p>标量</p><script type="math/tex; mode=display">\frac {\partial v_x}{\partial x}+\frac {\partial v_y}{\partial y}+\frac {\partial v_z}{\partial z}</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>散度</strong><br>记为$div\;v$或者$\nabla \cdot v​$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有关梯度旋度和散度的定义和计算,记录一下&lt;/p&gt;
&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h2&gt;&lt;h3 id=&quot;1-1梯度&quot;&gt;&lt;a href=&quot;#1-1梯度&quot; class
      
    
    </summary>
    
      <category term="数学" scheme="https://www.vhcffh.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="基础知识" scheme="https://www.vhcffh.com/categories/%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="梯度" scheme="https://www.vhcffh.com/tags/%E6%A2%AF%E5%BA%A6/"/>
    
      <category term="旋度" scheme="https://www.vhcffh.com/tags/%E6%97%8B%E5%BA%A6/"/>
    
      <category term="散度" scheme="https://www.vhcffh.com/tags/%E6%95%A3%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="https://www.vhcffh.com/2018/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.vhcffh.com/2018/vim的使用/</id>
    <published>2018-06-23T02:01:00.000Z</published>
    <updated>2019-08-10T10:26:06.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h3><p>h,j,k,l(空格):向左，下，上，右移动光标</p><p>Ctrl+(f,b,d,u):屏幕向下移一页，向上移一页，向下移半页，向上移半页<br>+-:下一行，上一行<br>H,M,L:光标移动到这个屏幕的最上方，中央，最下方那一行的第一个字符<br>G,nG,gg:移动都文档末，移动到第n行，移动到第一行<br>n:向下移动n行</p><h3 id="2-搜索替换"><a href="#2-搜索替换" class="headerlink" title="2.搜索替换"></a>2.搜索替换</h3><p>/word:向光标之下寻找word<br>?word:向光标之上寻找word<br>n,N:重复搜索（不变方向，改变方向）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-vim.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-光标移动&quot;&gt;&lt;a href=&quot;#1-光标移动&quot; class=&quot;headerlink&quot; title=&quot;1.光标移动&quot;&gt;&lt;/a&gt;1.光标移动&lt;/h3&gt;&lt;p&gt;h,j,k,l(空格):向左，下，上，右移动光标&lt;/p&gt;
&lt;p&gt;Ctrl+(f,b,d,u):屏幕向下移一页
      
    
    </summary>
    
      <category term="软件使用" scheme="https://www.vhcffh.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="vim" scheme="https://www.vhcffh.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>python中关于路径的知识</title>
    <link href="https://www.vhcffh.com/2018/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.vhcffh.com/2018/python中关于路径的知识/</id>
    <published>2018-05-17T02:01:00.000Z</published>
    <updated>2019-08-10T10:24:51.767Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="lang-python">os.getcwd()#输出当前路径os.listdir()#输出当前路径下的所有文件夹名和文件名os.remove(&#39;filename.xxx&#39;)和os.unlink(&#39;filename.xxx&#39;)功能一样#删除文件filename.xxxos.rmdir(&#39;path&#39;)#删除目录（目录必须为空）os.removedirs(&#39;p1//p2//p3&#39;)#依次删除目录p3,p2,p1直到某一目录不为空os.chdir(&#39;path&#39;)#更改当前路径</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://www.cnblogs.com/yanglang/p/7610838.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/7610838.html</a><br>2.<a href="https://blog.csdn.net/muwinter/article/details/77196261" target="_blank" rel="noopener">https://blog.csdn.net/muwinter/article/details/77196261</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;os.getcwd()
#输出当前路径

os.listdir()
#输出当前路径下的所有文件夹名和文件名

os.remove(&amp;#39;filename.xxx&amp;#39;)和os.unlink(&amp;#39;filen
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="路径" scheme="https://www.vhcffh.com/tags/%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>python类和实例的一些属性</title>
    <link href="https://www.vhcffh.com/2018/python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"/>
    <id>https://www.vhcffh.com/2018/python类和实例的一些属性/</id>
    <published>2018-05-17T02:01:00.000Z</published>
    <updated>2019-08-10T10:25:18.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-self和-init"><a href="#1-self和-init" class="headerlink" title="1.self和__init__()"></a>1.self和__init__()</h2><p>self代表类的实例,如下：</p><pre><code class="lang-python">class Test:    a,b=&#39;classa&#39;,&#39;classb&#39;#类的属性    def __init__(self):        self.b=&#39;selfb&#39;#实例的属性        self.c=&#39;selfc&#39;print(Test.a)print(Test.b)#-output:classa classb-访问类的属性a=Test()print(a.a)#-output:classa-通过实例访问类的属性print(a.b)#-output:selfb-当实例和类都具有某属性时,输出实例属性print(a.c)print(Test.c)#output</code></pre><p>当实例和类有相同的属性时，如何通过实例访问类的属性呢？<br>可以通过__class__访问</p><h2 id="2-class"><a href="#2-class" class="headerlink" title="2.__class__"></a>2.__class__</h2><p>__class__是指实例所对应的类</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test:    a=&#39;classa&#39;    print(count)    def __init__(self):        self.a=&#39;selfa&#39;        print(self)        #-output:&lt;__main__.Test object at 0x055A1270&gt;        print(self.__class__)        #-output:&lt;class &#39;__main__.Test&#39;&gt;a=Test()print(&#39;实例a&#39;,a)#-output:&lt;__main__.Test object at 0x055A1270&gt;print(&#39;类Test&#39;,Test)#-output:&lt;class &#39;__main__.Test&#39;&gt;print(a.a,a.__class__.a)#-output:selfa classa</code></pre><p>通过__init__()可以实现对类的实例的统计</p><pre><code># -*- coding: utf-8 -*-class Test(object):    count=0    def __init__(self):        super(Test, self).__init__()        self.__class__.count+=1if __name__==&quot;__main__&quot;:    a=Test()    print(Test.count)    b=Test()    print(Test.count)    Test()    print(Test.count)</code></pre><p>输出为</p><pre><code>123</code></pre><p>每创建一个Test类的实例,Test.count都加1</p><h2 id="3-dict"><a href="#3-dict" class="headerlink" title="3.__dict__"></a>3.__dict__</h2><p>__dict__是一个字典，键是属性名，值为属性值。<br>类有自己的__dict__，类的实例也有自己的__dict__</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test(object):    classa=&#39;classa&#39;    def __init__(self):        super(Test, self).__init__()        self.selfb=&#39;selfb&#39;if __name__==&quot;__main__&quot;:    print(Test.__dict__)    a=Test()    print(a.__dict__)</code></pre><p>输出为</p><pre><code class="lang-shell">{&#39;__module__&#39;: &#39;__main__&#39;, &#39;classa&#39;: &#39;classa&#39;, &#39;__init__&#39;: &lt;function Test.__init__ at 0x04D03468&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Test&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Test&#39; objects&gt;, &#39;__doc__&#39;: None}{&#39;selfb&#39;: &#39;selfb&#39;}</code></pre><p>可见类Test有classa属性以及一些其他属性<br>类Test的实例a只有self.b属性</p><h2 id="4-len-self-函数"><a href="#4-len-self-函数" class="headerlink" title="4.__len__(self)函数"></a>4.__len__(self)函数</h2><p>返回元素个数，实现len()方法。即类实现了__len__()函数就可以使用len()函数</p><h2 id="5-getitem-self-key"><a href="#5-getitem-self-key" class="headerlink" title="5.__getitem__(self,key)"></a>5.__getitem__(self,key)</h2><p>实现字典一样的功能，当类的实例对象（假设为P）调用P[key]时，调用此函数返回。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1,<a href="https://docs.python.org/" target="_blank" rel="noopener">https://docs.python.org</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-self和-init&quot;&gt;&lt;a href=&quot;#1-self和-init&quot; class=&quot;headerlink&quot; title=&quot;1.self和__init__()&quot;&gt;&lt;/a&gt;1.self和__init__()&lt;/h2&gt;&lt;p&gt;self代表类的实例,如下：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python3之模块</title>
    <link href="https://www.vhcffh.com/2018/python3%E4%B9%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.vhcffh.com/2018/python3之模块/</id>
    <published>2018-04-28T02:01:00.000Z</published>
    <updated>2019-08-10T10:24:41.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-python3模块"><a href="#1-python3模块" class="headerlink" title="1.python3模块"></a>1.python3模块</h2><p>简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，变量，也可以包含可执行代码。</p><h2 id="2-模块的引入"><a href="#2-模块的引入" class="headerlink" title="2.模块的引入"></a>2.模块的引入</h2><h3 id="2-1import引入"><a href="#2-1import引入" class="headerlink" title="2.1import引入"></a>2.1import引入</h3><pre><code>import module1,[module2[,.........moduleN]]</code></pre><p>一个模块只会被导入一次，不管执行了多少次import，这样可以防止导入模块被重复执行。</p><h3 id="2-2from-import语句"><a href="#2-2from-import语句" class="headerlink" title="2.2from * import语句"></a>2.2from * import语句</h3><pre><code>from modname import name1,name2..........nameNfrom mod import func_1</code></pre><p>这个声明不会把整个mod模块导入到当前命名空间中，它只会将mod里的func_1单个引入到执行这个声明的模块的全局符号表。</p><p>from … import * ：这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。</p><h2 id="3-搜索路径"><a href="#3-搜索路径" class="headerlink" title="3.搜索路径"></a>3.搜索路径</h2><p>搜索顺序：当前目录-&gt;系统环境变量PATHONHOME-&gt;标准链接库目录<br>通过<code>sys.path</code>可查看搜索路径</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#39;&#39;, &#39;C:\\Python36\\python36.zip&#39;, &#39;C:\\Python36\\DLLs&#39;, &#39;C:\\Python36\\lib&#39;, &#39;C:\\Python36&#39;, &#39;C:\\Python36\\lib\\site-packages&#39;]</code></pre><h2 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4.命名空间"></a>4.命名空间</h2><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称（键）和它们各自相应的对象们（值）的字典。<br>函数内用到全局变量要用global语句，否则会当作局部变量处理</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题:"></a>其他问题:</h2><p>1.python模块里的可执行代码何时执行？<br>当导入模块时，python顶层的代码会执行一次，若要重新执行模块的顶层代码需要通道reload()函数<br>另外python3中的reload()需要从imp包中导入<br>2.关于python模块循环引入的问题？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.cnblogs.com/zhangxinqi/p/7905103.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxinqi/p/7905103.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-python3模块&quot;&gt;&lt;a href=&quot;#1-python3模块&quot; class=&quot;headerlink&quot; title=&quot;1.python3模块&quot;&gt;&lt;/a&gt;1.python3模块&lt;/h2&gt;&lt;p&gt;简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="模块" scheme="https://www.vhcffh.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>DEBUG常用功能</title>
    <link href="https://www.vhcffh.com/2018/DEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.vhcffh.com/2018/DEBUG常用功能/</id>
    <published>2018-02-12T02:01:00.000Z</published>
    <updated>2019-08-10T10:24:16.227Z</updated>
    
    <content type="html"><![CDATA[<p>window 10中DEBUG的安装,以及DEBUG调试中一些常用的命令</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>window 10中好像已经没有了Debug的调试工具，需要下载另外的软件</p><p>下载安装DOSBox.百度云下载地址：(DOSBOX)[<a href="https://pan.baidu.com/s/1cC3cuy" target="_blank" rel="noopener">https://pan.baidu.com/s/1cC3cuy</a>]<br>下载后先安装DOSBox0.74-win32-installer.exe<br>然后找到文件dos-box0.74.conf(C:\Users\username\AppData\Local\DOSBox)<br>添加两行  </p><pre><code class="lang-bat">MOUNT C E:\DEBUG                  # 将目录E:\DEBUG挂载为DOSBOX下的C:  set PATH=$PATH$;E:\DEBUG          # 将E:\DEBUG写入环境变量PATH中</code></pre><p>并将下载的MASM.exe,LINK.exe,debug.exe三个文件放入目录E:\DEBUG<br>打开软件，输入<code>c:</code>就可以使用debug命令了  </p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令:"></a>2.常用命令:</h3><p>R命令：查看改变CPU寄存器的内容<br>D命令：查看内存中的内容<br>E命令：改写内存中的内容<br>U命令：将内存中的机器指令翻译成汇编指令<br>T命令：执行一条机器指令<br>A命令：以汇编指令的格式在内存中写入一条机器指令<br>Q命令：退出DEBUG调试  </p><h3 id="3-命令具体使用实例"><a href="#3-命令具体使用实例" class="headerlink" title="3.命令具体使用实例"></a>3.命令具体使用实例</h3><h4 id="3-1R命令"><a href="#3-1R命令" class="headerlink" title="3.1R命令:"></a>3.1R命令:</h4><p>R命令：查看改变CPU寄存器的内容  </p><pre><code class="lang-bat">-r                          ;显示寄存器的值-r reg                      ;改变寄存器reg的值</code></pre><p><img src="/images/2018/2_12_R命令.PNG" alt="img"></p><h3 id="3-2D命令"><a href="#3-2D命令" class="headerlink" title="3.2D命令:"></a>3.2D命令:</h3><p>D命令：查看内存中的内容<br>默认显示128字节的内容  </p><pre><code class="lang-bat">-d                          ;默认地址-d 段地址:偏移地址            ;指定地址-d 段地址:偏一偏二            ;两个地址间的内容</code></pre><p><img src="/images/2018/2_12_D命令.PNG" alt="img"></p><h3 id="3-3E命令"><a href="#3-3E命令" class="headerlink" title="3.3E命令:"></a>3.3E命令:</h3><p>E命令：改写内存中的内容  </p><pre><code class="lang-bat">-e 起始地址 数据 数据 ...   -e 起始地址</code></pre><p><img src="/images/2018/2_12_E命令.PNG" alt="img"></p><h3 id="3-4U命令"><a href="#3-4U命令" class="headerlink" title="3.4U命令:"></a>3.4U命令:</h3><p>U命令：将内存中的机器指令翻译成汇编指令<br>与D命令有些类似<br><img src="/images/2018/2_12_U命令.PNG" alt="img"></p><h3 id="3-5T命令"><a href="#3-5T命令" class="headerlink" title="3.5T命令:"></a>3.5T命令:</h3><p>T命令：执行内存中的一条机器指令<br>指令位置由cs:ip确定<br><img src="/images/2018/2_12_T命令.PNG" alt="img"></p><h3 id="3-6A命令"><a href="#3-6A命令" class="headerlink" title="3.6A命令:"></a>3.6A命令:</h3><p>A命令：以汇编指令的格式在内存中写入一条机器指令<br><img src="/images/2018/2_12_A命令.PNG" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;window 10中DEBUG的安装,以及DEBUG调试中一些常用的命令&lt;/p&gt;
&lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;window 10中好像已经没有了D
      
    
    </summary>
    
      <category term="编程" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="汇编" scheme="https://www.vhcffh.com/categories/%E7%BC%96%E7%A8%8B/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="DEBUG" scheme="https://www.vhcffh.com/tags/DEBUG/"/>
    
  </entry>
  
</feed>
