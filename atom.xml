<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frey&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vhcffh.com/"/>
  <updated>2019-08-08T13:52:43.217Z</updated>
  <id>https://www.vhcffh.com/</id>
  
  <author>
    <name>Frey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习中Keras vs Pytorch</title>
    <link href="https://www.vhcffh.com/2019/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADKeras%20vs%20Pytorch/"/>
    <id>https://www.vhcffh.com/2019/深度学习中Keras vs Pytorch/</id>
    <published>2019-07-09T00:11:00.000Z</published>
    <updated>2019-08-08T13:52:43.217Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习框架Keras与Pytorch的区别与优劣<a href="https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d" target="_blank" rel="noopener">翻译</a><br><a id="more"></a><br><img src="/images/2019/7_11_pytorchvskears.png" alt="img" title="Keras vs PyTorch"></p><p>对于许多科学家，工程师和开发人员来说，TensorFlow是他们的第一个深度学习框架。 TensorFlow 1.0于2017年2月发布;但它对用户来说不是很友好。</p><p>在过去几年中，两个主要的深度学习库已经获得了巨大的普及，主要是因为它们比TensorFlow更容易使用：<strong>Keras</strong>和<strong>Pytorch</strong>。</p><p>本文将介绍Keras与Pytorch的4个不同点，以及为什么您可以选择一个库而不是另一个库。</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>Keras本身不是一个框架，但实际上是一个位于其他Deep Learning框架之上的高级API。目前它支持<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>，<a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a>和<a href="https://github.com/microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>。</p><p>Keras的优势在于它的易用性。它是迄今为止最容易去快速启动和运行的框架。定义神经网络非常直观，使用功能API允许人们将层定义为函数。</p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><p>Pytorch是由Facebook的AI研究小组开发的深度学习框架（如TensorFlow）。像Keras一样，它也对深度网络编程中比较复杂的一大部分进行了抽象。</p><p>在高级和低级编码风格方面，Pytorch位于Keras和TensorFlow之间。你比Keras有更多的灵活性和控制力，但与此同时你不必做任何疯狂的声明性编程。</p><p>深度学习练习者整天都在争论应该使用哪个框架。一般来说，这取决于个人喜好。但是在选择时你应该记住Keras和Pytorch的一些特性。</p><p><img src="/images/2019/7_10_keras.jpeg" alt="img" title="It&#39;s keras"></p><p><img src="/images/2019/7_10_pytorch.jpeg" alt="img" title="It&#39;s Pytorch!"></p><h2 id="1-用于定义模型的-类-Pytorch-vs-函数-Keras"><a href="#1-用于定义模型的-类-Pytorch-vs-函数-Keras" class="headerlink" title="(1)用于定义模型的 类(Pytorch) vs 函数(Keras)"></a>(1)用于定义模型的 类(Pytorch) vs 函数(Keras)</h2><p>要定义深度学习模型，Keras提供Functional API。 使用Functional API，神经网络被定义为一组顺序函数，一个接一个地应用。 例如，第一层的输出是第二层的输入。</p><pre><code class="lang-python">img_input = layers.Input(shape=input_shape)x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(img_input)    x = layers.Conv2D(64, (3, 3), activation=&#39;relu&#39;)(x)    x = layers.MaxPooling2D((2, 2), strides=(2, 2))(x)</code></pre><p>在Pytorch中，您将网络设置为一个类，该类继承了Torch库中的torch.nn.Module。 与Keras类似，Pytorch为您提供了层作为构建块，但由于它们位于Python类中，因此它们在类的__init__()方法中引用，并由类的forward()方法执行。</p><pre><code class="lang-python">class Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(3, 64, 3)        self.conv2 = nn.Conv2d(64, 64, 3)        self.pool = nn.MaxPool2d(2, 2)    def forward(self, x):        x = F.relu(self.conv1(x))        x = self.pool(F.relu(self.conv2(x)))        return xmodel = Net()</code></pre><p>因为Pytorch允许您访问所有Python的类功能而不是简单的函数调用，所以定义网络可以更清晰，更优雅地包含。 这真的没什么不好的，除非你觉得最重要的是尽可能快地编写代码，那么Keras会更容易使用。</p><h2 id="2-张量和计算图-Pytorch-vs-标准阵列-Keras"><a href="#2-张量和计算图-Pytorch-vs-标准阵列-Keras" class="headerlink" title="(2)张量和计算图(Pytorch) vs 标准阵列(Keras)"></a>(2)张量和计算图(Pytorch) vs 标准阵列(Keras)</h2><p>Keras API对程序员隐藏了的许多复杂细节。定义网络层非常直观，默认设置通常足以让您入门。</p><p>只有当你需要实现一个相当尖端或“异国情调”的模型时，你才真正需要去了解底层的TensorFlow。</p><p>棘手的部分是，当你真正去了解底层的TensorFlow代码时，你将获得随之而来的所有非常具有挑战性的部分！ 您需要确保所有矩阵乘法都排成一行。 哦，甚至不要去考虑尝试打印出图层的一个输出，因为您只能在终端上打印出一个漂亮的Tensor定义。</p><p>Pytorch在这些方面倾向于更加方便。 您需要知道每个层的输入和输出大小，但这可以很快掌握。 您不必处理构建一个您无法在调试中看到的抽象计算图。</p><p>Pytorch的另一个好处是你可以在Torch Tensors和Numpy阵列之间来回滑动。 如果你需要实现自定义的东西，那么在TF张量和Numpy阵列之间来回转换可能会很麻烦，需要开发人员对TensorFlow的Session有充分的了解。</p><p>Pytorch的交互性比想象中要简单得多。 您只需要知道两个操作：一个将Torch Tensor（一个Variable对象）转变到Numpy，另一个是相反的转换。</p><pre><code class="lang-python">a = torch.Tensor(2,2)print(a)b = a.numpy() #tensor 变为numpyprint(b)print(torch.from_numpy(b)) # numpy 变为tensor</code></pre><p>当然，如果你不需要实现任何花哨的东西，那么Keras会做得很好，因为你不会遇到任何TensorFlow障碍。 但如果你这样做，那么Pytorch可能会更顺畅。</p><h2 id="3-Training-models"><a href="#3-Training-models" class="headerlink" title="(3) Training models"></a>(3) Training models</h2><p>在Keras训练模型非常容易！ 只是一个简单的.fit()函数，你可以很轻松的进行训练。</p><pre><code class="lang-python">history = model.fit_generator(    generator=train_generator,    epochs=10,    validation_data=validation_generator)</code></pre><p>在Pytorch中训练一些模型需要一些步骤</p><ul><li>每一批次的训练开始时初始化梯度</li><li>在模型中运行前向传播</li><li>运行后向传播</li><li>计算损失和更新权重</li></ul><p>所以，就训练模型来说，PyTorch 较为繁琐。</p><pre><code class="lang-python">for epoch in range(2):  # loop over the dataset multiple times    running_loss = 0.0    for i, data in enumerate(trainloader, 0):        # Get the inputs; data is a list of [inputs, labels]        inputs, labels = data        # (1) Initialise gradients        optimizer.zero_grad()        # (2) Forward pass        outputs = net(inputs)        loss = criterion(outputs, labels)        # (3) Backward        loss.backward()        # (4) Compute the loss and update the weights        optimizer.step()</code></pre><h2 id="4-控制-CPU-vs-GPU-模式"><a href="#4-控制-CPU-vs-GPU-模式" class="headerlink" title="(4)控制 CPU vs GPU 模式"></a>(4)控制 CPU vs GPU 模式</h2><p>如果你已经安装了 tensorflow-gpu，则在 Keras 中能够使用 GPU 并且会默认完成。然后，如果你想要将某些运算转移至 CPU，则可以以单行方式完成。</p><pre><code class="lang-python">with tf.device(&#39;/cpu:0&#39;):    y = apply_non_max_suppression(x)</code></pre><p>但对于 PyTorch 来说，你必须显式地为每个 torch 张量和 numpy 变量启动 GPU。这样代码会比较混乱。并且如果你想在 CPU 和 GPU 之间来回移动以执行不同运算，则很容易出错。</p><p>例如，为了将之前的模型转移到 GPU 上运行，则需要以下步骤：</p><pre><code class="lang-python"># Get the GPU devicedevice = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)# Transfer the network to GPUnet.to(device)# Transfer the inputs and labels to GPUinputs, labels = data[0].to(device), data[1].to(device)</code></pre><p>因而，Keras 在简洁性和默认设置方面优于 PyTorch。</p><h2 id="选择-Keras-或-PyTorch-的一般性建议"><a href="#选择-Keras-或-PyTorch-的一般性建议" class="headerlink" title="选择 Keras 或 PyTorch 的一般性建议"></a>选择 Keras 或 PyTorch 的一般性建议</h2><p>作者通常建议初学者从 Keras 开始。Keras 绝对是理解和使用起来最简单的框架，能够很快地上手运行。你完全不需要担心 GPU 设置、处理抽象代码以及其他任何复杂的事情。你甚至可以在不接触任何 TensorFlow 单行代码的情况下，实现自定义层和损失函数。</p><p>但如果你开始深度了解到深度网络的更细粒度层面或者正在实现一些非标准的事情，则 PyTorch 是你的首选库。使用 PyTorch 需要进行一些额外操作，但这不会减缓你的进程。你依然能够快速实现、训练和测试网络，并享受简单调试带来的额外益处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习框架Keras与Pytorch的区别与优劣&lt;a href=&quot;https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻译&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python中遇到的问题</title>
    <link href="https://www.vhcffh.com/2019/python%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.vhcffh.com/2019/python中遇到的问题/</id>
    <published>2019-05-31T00:35:00.000Z</published>
    <updated>2019-08-08T13:57:43.879Z</updated>
    
    <content type="html"><![CDATA[<p>python中使用中遇到的各种问题<br><a id="more"></a></p><h3 id="1-列表的初始化"><a href="#1-列表的初始化" class="headerlink" title="1.列表的初始化"></a>1.列表的初始化</h3><p>当初始化一个n×n的列表时不能使用如下方法，</p><pre><code class="lang-python">In [1]: l=[[0]*3]*3 #如此初始化会导致其它行仅是第一行的引用而不是copyIn [2]: lOut[2]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]In [3]: l[0][0]=1 #改变其中一行的某个元素In [4]: lOut[4]: [[1, 0, 0], [1, 0, 0], [1, 0, 0]] #其他行跟着改变</code></pre><p>正确的方法应该如下</p><pre><code class="lang-python">In [5]: l=[[0 for _ in range(3)] for _ in range(3)] #或者l=[[0]*3 for _ in range(3)]In [6]: lOut[6]: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]In [7]: l[0][0]=1In [8]: lOut[8]: [[1, 0, 0], [0, 0, 0], [0, 0, 0]]</code></pre><h3 id="2-a-is-b与a-b-的区别"><a href="#2-a-is-b与a-b-的区别" class="headerlink" title="2.a is b与a==b 的区别"></a>2.a is b与a==b 的区别</h3><pre><code>a=&#39;vhcffh.com&#39;b=&#39;vhcffh.com&#39;a==b # True,a和b对应实例的内容是相同的a is b # False,a和b指向不同的实例b=aa is b # True,a和b指向同一个实例</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中使用中遇到的各种问题&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python常用方法</title>
    <link href="https://www.vhcffh.com/2019/python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.vhcffh.com/2019/python常用方法/</id>
    <published>2019-05-29T21:26:00.000Z</published>
    <updated>2019-08-08T13:56:14.648Z</updated>
    
    <content type="html"><![CDATA[<p>python中常用的一些方法sorted()等<br><a id="more"></a></p><h3 id="1-sorted排序"><a href="#1-sorted排序" class="headerlink" title="1.sorted排序"></a>1.sorted排序</h3><pre><code class="lang-python">sorted(iterable[, cmp[, key[, reverse]]])</code></pre><p>参数说明：</p><ul><li>iterable — 可迭代对象。</li><li>cmp — 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li><li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse — 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中常用的一些方法sorted()等&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.vhcffh.com/2019/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.vhcffh.com/2019/linux常用命令/</id>
    <published>2019-05-20T21:22:00.000Z</published>
    <updated>2019-08-08T13:59:53.267Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中的一些常用命令,tar<br><a id="more"></a></p><h2 id="1-tar解压打包相关"><a href="#1-tar解压打包相关" class="headerlink" title="1.tar解压打包相关"></a>1.tar解压打包相关</h2><pre><code class="lang-shell">tar -cvf log.tar log2019.log    #仅打包，不压缩tar -zcvf log.tar.gz log2019.log   #打包后，以 gzip 压缩tar -jcvf log.tar.bz2 log2019.log  #打包后，以 bzip2 压缩tar -ztvf log.tar.gz #gzip查阅tar -jtvf log.tar.gz #bzip2查阅tar -zxvf log.tar.gz #gzip解压tar -jxvf log.tar.gz #bzip2解压unzip log.zip -d dirname #zip解压到dirname目录</code></pre><p>补充</p><p>c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出 </p><h2 id="2-wget设置代理"><a href="#2-wget设置代理" class="headerlink" title="2.wget设置代理"></a>2.wget设置代理</h2><h3 id="2-1环境变量中设置"><a href="#2-1环境变量中设置" class="headerlink" title="2.1环境变量中设置"></a>2.1环境变量中设置</h3><pre><code class="lang-shell">export http_proxy=http://127.0.0.1:8087</code></pre><h3 id="2-2使用配置文件"><a href="#2-2使用配置文件" class="headerlink" title="2.2使用配置文件"></a>2.2使用配置文件</h3><pre><code class="lang-shell"># cp /etc/wgetrc ~/.wgetrc# vim ~/.wgetrc# You can set the default proxies for Wget to use for http, https, and ftp.# They will override the value in the environment.https_proxy = http://127.0.0.1:8087/http_proxy = http://127.0.0.1:8087/ftp_proxy = http://127.0.0.1:8087/# If you do not want to use proxy at all, set this to off.use_proxy = on</code></pre><h2 id="3-ps相关命令"><a href="#3-ps相关命令" class="headerlink" title="3.ps相关命令"></a>3.ps相关命令</h2><pre><code class="lang-shell">ps -ef # 查看进程信息和执行的命令</code></pre><h2 id="4-用户文件管理相关"><a href="#4-用户文件管理相关" class="headerlink" title="4.用户文件管理相关"></a>4.用户文件管理相关</h2><h3 id="4-1Linux系统用户账号的管理"><a href="#4-1Linux系统用户账号的管理" class="headerlink" title="4.1Linux系统用户账号的管理"></a>4.1Linux系统用户账号的管理</h3><h4 id="4-1-1添加新的用户账号"><a href="#4-1-1添加新的用户账号" class="headerlink" title="4.1.1添加新的用户账号"></a>4.1.1添加新的用户账号</h4><pre><code class="lang-shell">useradd [-d dirname] username# [-d dirname]指定用户主目录</code></pre><h4 id="4-1-2删除帐号"><a href="#4-1-2删除帐号" class="headerlink" title="4.1.2删除帐号"></a>4.1.2删除帐号</h4><pre><code class="lang-shell">userdel [-r] username# [-R]把用户的主目录一起删除</code></pre><h4 id="4-1-3修改帐号"><a href="#4-1-3修改帐号" class="headerlink" title="4.1.3修改帐号"></a>4.1.3修改帐号</h4><pre><code class="lang-shell">usermod [] username</code></pre><h4 id="4-1-4用户密码管理"><a href="#4-1-4用户密码管理" class="headerlink" title="4.1.4用户密码管理"></a>4.1.4用户密码管理</h4><pre><code class="lang-shell">passwd [-I][-u][-d][-f] username# [-I]锁定密码，即禁用账号。# [-u]密码解锁。# [-d]使账号无密码。# [-f]强迫用户下次登录时修改密码。</code></pre><h3 id="4-2Linux系统用户组的管理"><a href="#4-2Linux系统用户组的管理" class="headerlink" title="4.2Linux系统用户组的管理"></a>4.2Linux系统用户组的管理</h3><h4 id="4-2-1增加一个新的用户组"><a href="#4-2-1增加一个新的用户组" class="headerlink" title="4.2.1增加一个新的用户组"></a>4.2.1增加一个新的用户组</h4><pre><code class="lang-shell">groupadd [-g GID] username# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-2删除一个已有的用户组"><a href="#4-2-2删除一个已有的用户组" class="headerlink" title="4.2.2删除一个已有的用户组"></a>4.2.2删除一个已有的用户组</h4><pre><code class="lang-shell">groupdel groupname</code></pre><h4 id="4-2-3修改用户组的属性"><a href="#4-2-3修改用户组的属性" class="headerlink" title="4.2.3修改用户组的属性"></a>4.2.3修改用户组的属性</h4><pre><code class="lang-shell">groupmod [-g GID] groupname# [-g GID]指定新用户组的组标识号（GID）</code></pre><h4 id="4-2-4更改用户组"><a href="#4-2-4更改用户组" class="headerlink" title="4.2.4更改用户组"></a>4.2.4更改用户组</h4><p><strong>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。</strong></p><pre><code class="lang-shell">newgrp root</code></pre><h3 id="4-3Linux文件用户属性修改"><a href="#4-3Linux文件用户属性修改" class="headerlink" title="4.3Linux文件用户属性修改"></a>4.3Linux文件用户属性修改</h3><pre><code class="lang-shell">chown [-R] user_name filename_OR_dirname  # 更改文件或目录的所有者chgrp [-R] group_name filename_OR_dirname  # 更改文件或目录所在组# [-R]参数递归更改目录下所有文件的用户属性</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://man.linuxde.net/tar" target="_blank" rel="noopener">http://man.linuxde.net/tar</a></p><p>2.<a href="https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html" target="_blank" rel="noopener">https://www.cnblogs.com/cloud2rain/archive/2013/03/22/2976337.html</a></p><p>3.<a href="https://www.cnblogs.com/52php/p/5677628.html" target="_blank" rel="noopener">https://www.cnblogs.com/52php/p/5677628.html</a></p><p>4.<a href="https://www.jb51.net/LINUXjishu/43356.html" target="_blank" rel="noopener">https://www.jb51.net/LINUXjishu/43356.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux中的一些常用命令,tar&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://www.vhcffh.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>简单的iptables配置过程</title>
    <link href="https://www.vhcffh.com/2018/%E7%AE%80%E5%8D%95%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>https://www.vhcffh.com/2018/简单的iptables配置过程/</id>
    <published>2018-10-19T02:01:00.000Z</published>
    <updated>2019-08-08T15:21:07.790Z</updated>
    
    <content type="html"><![CDATA[<p>简单的记一下iptables的配置过程，以后用到了就不用再google了<br>总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则</p><h2 id="iptables配置过程"><a href="#iptables配置过程" class="headerlink" title="iptables配置过程"></a>iptables配置过程</h2><h3 id="1-清除规则"><a href="#1-清除规则" class="headerlink" title="1.清除规则:"></a>1.清除规则:</h3><p>清楚旧的规则<br>iptables -F 清除预设表filter中的所有规则链的规则<br>iptables -X 清除预设表filter中使用者自定链中的规则</p><h3 id="2-设定预设规则"><a href="#2-设定预设规则" class="headerlink" title="2.设定预设规则"></a>2.设定预设规则</h3><p>默认情况下对各种包的处理方式<br>iptables -p INPUT DROP<br>iptables -p OUTPUT ACCEPT<br>iptables -p FORWARD DROP</p><h3 id="3-添加用户自定义规则"><a href="#3-添加用户自定义规则" class="headerlink" title="3.添加用户自定义规则"></a>3.添加用户自定义规则</h3><p>对于特定端口协议的包的规则进行设置<br>iptables -A INPUT -p tcp —dport 22 -j ACCEPT<br>-A:表示添加规则到INPUT(OUTPUT,FORWARD)链<br>-p:表示tcp(udp)协议<br>—dport(—sport):目的端口号(源端口号)<br>-j():添加规则为接受</p><h3 id="4-保存规则"><a href="#4-保存规则" class="headerlink" title="4.保存规则"></a>4.保存规则</h3><p>不保存的话重启后就没有了<br>service iptables save</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html" target="_blank" rel="noopener">http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的记一下iptables的配置过程，以后用到了就不用再google了&lt;br&gt;总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则&lt;/p&gt;
&lt;h2 id=&quot;iptables配置过程&quot;&gt;&lt;a href=&quot;#iptables配置过程&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/Linux/"/>
    
    
      <category term="服务器" scheme="https://www.vhcffh.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="系统" scheme="https://www.vhcffh.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>socket网络编程</title>
    <link href="https://www.vhcffh.com/2018/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.vhcffh.com/2018/socket网络编程/</id>
    <published>2018-10-18T02:01:00.000Z</published>
    <updated>2019-08-08T14:32:33.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h3><pre><code class="lang-c">int inet_aton(const char *cp, struct in_addr *inp);</code></pre><p>转换网络主机地址为二进制数值并存储与第二个参数中<br>函数返回0表示主机地址无效，非0表示主机地址有效<br>转化完后需要调用htons或htonl函数才能将主机字节序转换为网络字节序用于网络传输</p><pre><code class="lang-c">char *inet_ntoa(struct in_addr in);</code></pre><p>转换网络字节序为标准的ASCII以点分开的地址，函数返回字符串指针<br>该字符串空间为静态分配，第二次调用时会覆盖第一次的内容</p><pre><code class="lang-c">in_addr_t inet_addr(const char *cp);</code></pre><p>转换网络主机地址为网络字节序二进制值<br>参数无效，返回-1(INADDR_NONE)<br>注意：转换255.255.255.255时也返回-1</p><pre><code class="lang-c">int inet_pton(int af, const char *src, void *dst);</code></pre><p>转换字符串到网络地址，af是地址簇，<em>src是来源地址，</em> dst接收转换后的数据。</p><pre><code class="lang-c">const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);</code></pre><p>转换网络字节序二进制值到ASCII类型的地址，参数的作用和inet_pton相同，<br>socklen_t cnt指所指向缓存区dst的大小，避免溢出，如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。</p><pre><code class="lang-c">int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);</code></pre><p>int maxfdp 指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。<br>struct fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄。监视这些文件描述符的读变化</p><pre><code class="lang-c">int setsockopt(SOCKET s,int level,int optname,const char* optval,int optlen);</code></pre><p>s(套接字): 指向一个打开的套接口描述字<br>level:(级别)： 指定选项代码的类型。<br>SOL_SOCKET: 基本套接口<br>IPPROTO_IP: IPv4套接口<br>IPPROTO_IPV6: IPv6套接口<br>IPPROTO_TCP: TCP套接口<br>optname(选项名)： 选项名称<br>optval(选项值): 是一个指向变量的指针 类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }<br>optlen(选项长度) ：optval 的大小</p><pre><code class="lang-c">int PASCAL FAR recvfrom( SOCKET s, char FAR* buf, int len, int flags,struct sockaddr FAR* from, int FAR* fromlen);</code></pre><p>s：标识一个已连接套接口的描述字。<br>buf：接收数据缓冲区。<br>len：缓冲区长度。<br>flags：调用操作方式。<br>from：（可选）指针，指向装有源地址的缓冲区。<br>fromlen：（可选）指针，指向from缓冲区长度值。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://blog.csdn.net/zyy617532750/article/details/58595700" target="_blank" rel="noopener">https://blog.csdn.net/zyy617532750/article/details/58595700</a><br>2.<a href="https://www.cnblogs.com/zhoudingcocng/p/6209961.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoudingcocng/p/6209961.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;socket网络编程&quot;&gt;&lt;a href=&quot;#socket网络编程&quot; class=&quot;headerlink&quot; title=&quot;socket网络编程&quot;&gt;&lt;/a&gt;socket网络编程&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;int inet_aton(c
      
    
    </summary>
    
      <category term="C/C++" scheme="https://www.vhcffh.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="https://www.vhcffh.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="socket" scheme="https://www.vhcffh.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机基础知识</title>
    <link href="https://www.vhcffh.com/2018/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.vhcffh.com/2018/形式语言与自动机基础知识/</id>
    <published>2018-09-22T02:01:00.000Z</published>
    <updated>2019-08-09T12:07:49.654Z</updated>
    
    <content type="html"><![CDATA[<p>形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识</p><h2 id="1-集合及其运算"><a href="#1-集合及其运算" class="headerlink" title="1.集合及其运算"></a>1.集合及其运算</h2><h3 id="1-1子集和真子集"><a href="#1-1子集和真子集" class="headerlink" title="1.1子集和真子集"></a>1.1子集和真子集</h3><p>$A$子集：$A \subseteq B​$或$B \subseteq A​$<br>$A​$是$B​$的真子集：$A \subset B​$或$B \subset A​$<br>$x​$是$A​$的一个元素：$x \in A​$<br>$x​$不是$A​$的一个元素：$x \notin A​$</p><h3 id="1-2集合的交并差补"><a href="#1-2集合的交并差补" class="headerlink" title="1.2集合的交并差补"></a>1.2集合的交并差补</h3><p>$A$和$B$的并集：$A\cup B={x|x\in A或x\in B}$<br>$A$和$B$的交集：$A\cap B={x|x\in A且x\in B}$<br>$A$和$B$的差集：$A - B={x|x\in A且x\notin B}$<br>若$B\subseteq A$我们也称$A−B$为$B$的（关于$A$）补,记作：$\overline B(A)​$</p><h3 id="1-3集合的并的推广"><a href="#1-3集合的并的推广" class="headerlink" title="1.3集合的并的推广"></a>1.3集合的并的推广</h3><p>设$I​$是某些标号的集合我们将$\displaystyle \bigcup_{i\in I}A_i={x|存在i\in I,使得x\in A_i}​$</p><h3 id="1-4A的幂集"><a href="#1-4A的幂集" class="headerlink" title="1.4A的幂集"></a>1.4A的幂集</h3><p>$A$的所有子集的集合，记作$2^A={B|B\subseteq A}​$</p><h3 id="1-5笛卡尔乘积"><a href="#1-5笛卡尔乘积" class="headerlink" title="1.5笛卡尔乘积"></a>1.5笛卡尔乘积</h3><p>$A\times B={(a,b)|a\in A且b\in B}$</p><h3 id="1-6集合之间的关系"><a href="#1-6集合之间的关系" class="headerlink" title="1.6集合之间的关系"></a>1.6集合之间的关系</h3><p>由$A$到$B$的关系是$A×B$的任何子集。若$A=B$，则称为$A$上的关系。若$R$为$A$到$B$的关系，当$(a,b)$在$R$内时，可写成$aRb​$</p><h3 id="1-7集合关系的性质"><a href="#1-7集合关系的性质" class="headerlink" title="1.7集合关系的性质"></a>1.7集合关系的性质</h3><p>设$R$是集合$A$上的关系，则有<br>（1）若对$A$中的任一元素$a$，都有$aRa$，则称$R$是<strong>自反的</strong>；<br>（2）若对$A$中的任何元素$a,b$，从$aRb$能够推到出$bRa$，则称$R$是<strong>对称的</strong>；<br>（3）若$a,b,c$是$A$中的元素，从$aRb$和$bRc$能够推出$aRc$，则称$R$是<strong>传递的</strong>；<br>若关系$R​$同时是自反的，对称的和传递的，则称之为<strong>等价关系</strong>。<br>2018-09-22 15:28:12</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.《形式语言与自动机》陈有祺编著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识&lt;/p&gt;
&lt;h2 id=&quot;1-集合及其运算&quot;&gt;&lt;a href=&quot;#1-集合及其运算&quot; class=&quot;headerlink&quot; title=&quot;1.集合及其运算&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://www.vhcffh.com/categories/Mathematics/"/>
    
    
      <category term="math" scheme="https://www.vhcffh.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>梯度旋度和散度</title>
    <link href="https://www.vhcffh.com/2018/%E6%A2%AF%E5%BA%A6%E6%97%8B%E5%BA%A6%E5%92%8C%E6%95%A3%E5%BA%A6/"/>
    <id>https://www.vhcffh.com/2018/梯度旋度和散度/</id>
    <published>2018-09-08T02:01:00.000Z</published>
    <updated>2019-08-09T11:08:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>有关梯度旋度和散度的定义和计算,记录一下</p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><h3 id="1-1梯度"><a href="#1-1梯度" class="headerlink" title="1.1梯度"></a>1.1梯度</h3><p>设函数$u=f(x,y,z)$在空间区域\(G\)内具有一阶连续偏导数,其中点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">\left\{  \frac {\partial f}{\partial x},  \frac {\partial f}{\partial y},  \frac {\partial f}{\partial z}\right\}=\frac {\partial f}{\partial x}\vec i+\frac {\partial f}{\partial y}\vec j+\frac {\partial f}{\partial z}\vec k</script><p>为函数$u=f(x,y,z)$在点$P(x,y,z)​$的<strong>梯度</strong><br>记为$gradf(x,y,z)​$或$\nabla f(x,y,z)$</p><p>(注:</p><script type="math/tex; mode=display">\nabla = \frac {\partial}{\partial x}\vec i+\frac {\partial}{\partial y}\vec j+\frac {\partial}{\partial z}\vec k</script><p>称为三维的向量微分算子)</p><h3 id="1-2旋度"><a href="#1-2旋度" class="headerlink" title="1.2旋度"></a>1.2旋度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}​$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G$</p><p>向量</p><script type="math/tex; mode=display">  \begin{vmatrix}  \vec i & \vec j & \vec k \\  \frac {\partial}{\partial x} & \frac {\partial}{\partial y} & \frac {\partial}{\partial z} \\  v_x & v_y & v_z \\  \end{vmatrix} =   (\frac {\partial v_z}{\partial y} - \frac {\partial v_y}{\partial z})\vec i+  (\frac {\partial v_x}{\partial z} - \frac {\partial v_z}{\partial x})\vec j+  (\frac {\partial v_y}{\partial x} - \frac {\partial v_x}{\partial y})\vec k</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>旋度</strong><br>记为$curl\;v$或者$\nabla \times v$</p><h3 id="1-3散度"><a href="#1-3散度" class="headerlink" title="1.3散度"></a>1.3散度</h3><p>在三维空间$G$中有三维直角坐标系$O_{xyz}$,设向量场:</p><script type="math/tex; mode=display">\vec v=v_x\vec i+v_y\vec j+v_z\vec k</script><p>其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G​$</p><p>标量</p><script type="math/tex; mode=display">\frac {\partial v_x}{\partial x}+\frac {\partial v_y}{\partial y}+\frac {\partial v_z}{\partial z}</script><p>为向量场$\vec v$在点$P(x,y,z)$的<strong>散度</strong><br>记为$div\;v$或者$\nabla \cdot v​$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有关梯度旋度和散度的定义和计算,记录一下&lt;/p&gt;
&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h2&gt;&lt;h3 id=&quot;1-1梯度&quot;&gt;&lt;a href=&quot;#1-1梯度&quot; class
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://www.vhcffh.com/categories/Mathematics/"/>
    
    
      <category term="math" scheme="https://www.vhcffh.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="https://www.vhcffh.com/2018/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.vhcffh.com/2018/vim的使用/</id>
    <published>2018-06-23T02:01:00.000Z</published>
    <updated>2019-08-08T14:33:23.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h3><p>h,j,k,l(空格):向左，下，上，右移动光标</p><p>Ctrl+(f,b,d,u):屏幕向下移一页，向上移一页，向下移半页，向上移半页<br>+-:下一行，上一行<br>H,M,L:光标移动到这个屏幕的最上方，中央，最下方那一行的第一个字符<br>G,nG,gg:移动都文档末，移动到第n行，移动到第一行<br>n:向下移动n行</p><h3 id="2-搜索替换"><a href="#2-搜索替换" class="headerlink" title="2.搜索替换"></a>2.搜索替换</h3><p>/word:向光标之下寻找word<br>?word:向光标之上寻找word<br>n,N:重复搜索（不变方向，改变方向）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-vim.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-光标移动&quot;&gt;&lt;a href=&quot;#1-光标移动&quot; class=&quot;headerlink&quot; title=&quot;1.光标移动&quot;&gt;&lt;/a&gt;1.光标移动&lt;/h3&gt;&lt;p&gt;h,j,k,l(空格):向左，下，上，右移动光标&lt;/p&gt;
&lt;p&gt;Ctrl+(f,b,d,u):屏幕向下移一页
      
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="vim" scheme="https://www.vhcffh.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>python中关于路径的知识</title>
    <link href="https://www.vhcffh.com/2018/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.vhcffh.com/2018/python中关于路径的知识/</id>
    <published>2018-05-17T02:01:00.000Z</published>
    <updated>2019-08-08T15:21:43.851Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="lang-python">os.getcwd()#输出当前路径os.listdir()#输出当前路径下的所有文件夹名和文件名os.remove(&#39;filename.xxx&#39;)和os.unlink(&#39;filename.xxx&#39;)功能一样#删除文件filename.xxxos.rmdir(&#39;path&#39;)#删除目录（目录必须为空）os.removedirs(&#39;p1//p2//p3&#39;)#依次删除目录p3,p2,p1直到某一目录不为空os.chdir(&#39;path&#39;)#更改当前路径</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://www.cnblogs.com/yanglang/p/7610838.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/7610838.html</a><br>2.<a href="https://blog.csdn.net/muwinter/article/details/77196261" target="_blank" rel="noopener">https://blog.csdn.net/muwinter/article/details/77196261</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;os.getcwd()
#输出当前路径

os.listdir()
#输出当前路径下的所有文件夹名和文件名

os.remove(&amp;#39;filename.xxx&amp;#39;)和os.unlink(&amp;#39;filen
      
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python类和实例的一些属性</title>
    <link href="https://www.vhcffh.com/2018/python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7/"/>
    <id>https://www.vhcffh.com/2018/python类和实例的一些属性/</id>
    <published>2018-05-17T02:01:00.000Z</published>
    <updated>2019-08-08T15:21:31.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-self和-init"><a href="#1-self和-init" class="headerlink" title="1.self和__init__()"></a>1.self和__init__()</h2><p>self代表类的实例,如下：</p><pre><code class="lang-python">class Test:    a,b=&#39;classa&#39;,&#39;classb&#39;#类的属性    def __init__(self):        self.b=&#39;selfb&#39;#实例的属性        self.c=&#39;selfc&#39;print(Test.a)print(Test.b)#-output:classa classb-访问类的属性a=Test()print(a.a)#-output:classa-通过实例访问类的属性print(a.b)#-output:selfb-当实例和类都具有某属性时,输出实例属性print(a.c)print(Test.c)#output</code></pre><p>当实例和类有相同的属性时，如何通过实例访问类的属性呢？<br>可以通过__class__访问</p><h2 id="2-class"><a href="#2-class" class="headerlink" title="2.__class__"></a>2.__class__</h2><p>__class__是指实例所对应的类</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test:    a=&#39;classa&#39;    print(count)    def __init__(self):        self.a=&#39;selfa&#39;        print(self)        #-output:&lt;__main__.Test object at 0x055A1270&gt;        print(self.__class__)        #-output:&lt;class &#39;__main__.Test&#39;&gt;a=Test()print(&#39;实例a&#39;,a)#-output:&lt;__main__.Test object at 0x055A1270&gt;print(&#39;类Test&#39;,Test)#-output:&lt;class &#39;__main__.Test&#39;&gt;print(a.a,a.__class__.a)#-output:selfa classa</code></pre><p>通过__init__()可以实现对类的实例的统计</p><pre><code># -*- coding: utf-8 -*-class Test(object):    count=0    def __init__(self):        super(Test, self).__init__()        self.__class__.count+=1if __name__==&quot;__main__&quot;:    a=Test()    print(Test.count)    b=Test()    print(Test.count)    Test()    print(Test.count)</code></pre><p>输出为</p><pre><code>123</code></pre><p>每创建一个Test类的实例,Test.count都加1</p><h2 id="3-dict"><a href="#3-dict" class="headerlink" title="3.__dict__"></a>3.__dict__</h2><p>__dict__是一个字典，键是属性名，值为属性值。<br>类有自己的__dict__，类的实例也有自己的__dict__</p><pre><code class="lang-python"># -*- coding: utf-8 -*-class Test(object):    classa=&#39;classa&#39;    def __init__(self):        super(Test, self).__init__()        self.selfb=&#39;selfb&#39;if __name__==&quot;__main__&quot;:    print(Test.__dict__)    a=Test()    print(a.__dict__)</code></pre><p>输出为</p><pre><code class="lang-shell">{&#39;__module__&#39;: &#39;__main__&#39;, &#39;classa&#39;: &#39;classa&#39;, &#39;__init__&#39;: &lt;function Test.__init__ at 0x04D03468&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Test&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Test&#39; objects&gt;, &#39;__doc__&#39;: None}{&#39;selfb&#39;: &#39;selfb&#39;}</code></pre><p>可见类Test有classa属性以及一些其他属性<br>类Test的实例a只有self.b属性</p><h2 id="4-len-self-函数"><a href="#4-len-self-函数" class="headerlink" title="4.__len__(self)函数"></a>4.__len__(self)函数</h2><p>返回元素个数，实现len()方法。即类实现了__len__()函数就可以使用len()函数</p><h2 id="5-getitem-self-key"><a href="#5-getitem-self-key" class="headerlink" title="5.__getitem__(self,key)"></a>5.__getitem__(self,key)</h2><p>实现字典一样的功能，当类的实例对象（假设为P）调用P[key]时，调用此函数返回。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1,<a href="https://docs.python.org/" target="_blank" rel="noopener">https://docs.python.org</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-self和-init&quot;&gt;&lt;a href=&quot;#1-self和-init&quot; class=&quot;headerlink&quot; title=&quot;1.self和__init__()&quot;&gt;&lt;/a&gt;1.self和__init__()&lt;/h2&gt;&lt;p&gt;self代表类的实例,如下：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python3之模块</title>
    <link href="https://www.vhcffh.com/2018/python3%E4%B9%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.vhcffh.com/2018/python3之模块/</id>
    <published>2018-04-28T02:01:00.000Z</published>
    <updated>2019-08-08T15:21:55.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-python3模块"><a href="#1-python3模块" class="headerlink" title="1.python3模块"></a>1.python3模块</h2><p>简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，变量，也可以包含可执行代码。</p><h2 id="2-模块的引入"><a href="#2-模块的引入" class="headerlink" title="2.模块的引入"></a>2.模块的引入</h2><h3 id="2-1import引入"><a href="#2-1import引入" class="headerlink" title="2.1import引入"></a>2.1import引入</h3><pre><code>import module1,[module2[,.........moduleN]]</code></pre><p>一个模块只会被导入一次，不管执行了多少次import，这样可以防止导入模块被重复执行。</p><h3 id="2-2from-import语句"><a href="#2-2from-import语句" class="headerlink" title="2.2from * import语句"></a>2.2from * import语句</h3><pre><code>from modname import name1,name2..........nameNfrom mod import func_1</code></pre><p>这个声明不会把整个mod模块导入到当前命名空间中，它只会将mod里的func_1单个引入到执行这个声明的模块的全局符号表。</p><p>from … import * ：这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。</p><h2 id="3-搜索路径"><a href="#3-搜索路径" class="headerlink" title="3.搜索路径"></a>3.搜索路径</h2><p>搜索顺序：当前目录-&gt;系统环境变量PATHONHOME-&gt;标准链接库目录<br>通过<code>sys.path</code>可查看搜索路径</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#39;&#39;, &#39;C:\\Python36\\python36.zip&#39;, &#39;C:\\Python36\\DLLs&#39;, &#39;C:\\Python36\\lib&#39;, &#39;C:\\Python36&#39;, &#39;C:\\Python36\\lib\\site-packages&#39;]</code></pre><h2 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4.命名空间"></a>4.命名空间</h2><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称（键）和它们各自相应的对象们（值）的字典。<br>函数内用到全局变量要用global语句，否则会当作局部变量处理</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题:"></a>其他问题:</h2><p>1.python模块里的可执行代码何时执行？<br>当导入模块时，python顶层的代码会执行一次，若要重新执行模块的顶层代码需要通道reload()函数<br>另外python3中的reload()需要从imp包中导入<br>2.关于python模块循环引入的问题？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.cnblogs.com/zhangxinqi/p/7905103.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxinqi/p/7905103.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-python3模块&quot;&gt;&lt;a href=&quot;#1-python3模块&quot; class=&quot;headerlink&quot; title=&quot;1.python3模块&quot;&gt;&lt;/a&gt;1.python3模块&lt;/h2&gt;&lt;p&gt;简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，
      
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>DEBUG常用功能</title>
    <link href="https://www.vhcffh.com/2018/DEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.vhcffh.com/2018/DEBUG常用功能/</id>
    <published>2018-02-12T02:01:00.000Z</published>
    <updated>2019-08-08T15:22:08.381Z</updated>
    
    <content type="html"><![CDATA[<p>window 10中DEBUG的安装,以及DEBUG调试中一些常用的命令</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>window 10中好像已经没有了Debug的调试工具，需要下载另外的软件</p><p>下载安装DOSBox.百度云下载地址：(DOSBOX)[<a href="https://pan.baidu.com/s/1cC3cuy" target="_blank" rel="noopener">https://pan.baidu.com/s/1cC3cuy</a>]<br>下载后先安装DOSBox0.74-win32-installer.exe<br>然后找到文件dos-box0.74.conf(C:\Users\username\AppData\Local\DOSBox)<br>添加两行  </p><pre><code class="lang-bat">MOUNT C E:\DEBUG                  # 将目录E:\DEBUG挂载为DOSBOX下的C:  set PATH=$PATH$;E:\DEBUG          # 将E:\DEBUG写入环境变量PATH中</code></pre><p>并将下载的MASM.exe,LINK.exe,debug.exe三个文件放入目录E:\DEBUG<br>打开软件，输入<code>c:</code>就可以使用debug命令了  </p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令:"></a>2.常用命令:</h3><p>R命令：查看改变CPU寄存器的内容<br>D命令：查看内存中的内容<br>E命令：改写内存中的内容<br>U命令：将内存中的机器指令翻译成汇编指令<br>T命令：执行一条机器指令<br>A命令：以汇编指令的格式在内存中写入一条机器指令<br>Q命令：退出DEBUG调试  </p><h3 id="3-命令具体使用实例"><a href="#3-命令具体使用实例" class="headerlink" title="3.命令具体使用实例"></a>3.命令具体使用实例</h3><h4 id="3-1R命令"><a href="#3-1R命令" class="headerlink" title="3.1R命令:"></a>3.1R命令:</h4><p>R命令：查看改变CPU寄存器的内容  </p><pre><code class="lang-bat">-r                          ;显示寄存器的值-r reg                      ;改变寄存器reg的值</code></pre><p><img src="/images/2018/2_12_R命令.PNG" alt="img"></p><h3 id="3-2D命令"><a href="#3-2D命令" class="headerlink" title="3.2D命令:"></a>3.2D命令:</h3><p>D命令：查看内存中的内容<br>默认显示128字节的内容  </p><pre><code class="lang-bat">-d                          ;默认地址-d 段地址:偏移地址            ;指定地址-d 段地址:偏一偏二            ;两个地址间的内容</code></pre><p><img src="/images/2018/2_12_D命令.PNG" alt="img"></p><h3 id="3-3E命令"><a href="#3-3E命令" class="headerlink" title="3.3E命令:"></a>3.3E命令:</h3><p>E命令：改写内存中的内容  </p><pre><code class="lang-bat">-e 起始地址 数据 数据 ...   -e 起始地址</code></pre><p><img src="/images/2018/2_12_E命令.PNG" alt="img"></p><h3 id="3-4U命令"><a href="#3-4U命令" class="headerlink" title="3.4U命令:"></a>3.4U命令:</h3><p>U命令：将内存中的机器指令翻译成汇编指令<br>与D命令有些类似<br><img src="/images/2018/2_12_U命令.PNG" alt="img"></p><h3 id="3-5T命令"><a href="#3-5T命令" class="headerlink" title="3.5T命令:"></a>3.5T命令:</h3><p>T命令：执行内存中的一条机器指令<br>指令位置由cs:ip确定<br><img src="/images/2018/2_12_T命令.PNG" alt="img"></p><h3 id="3-6A命令"><a href="#3-6A命令" class="headerlink" title="3.6A命令:"></a>3.6A命令:</h3><p>A命令：以汇编指令的格式在内存中写入一条机器指令<br><img src="/images/2018/2_12_A命令.PNG" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;window 10中DEBUG的安装,以及DEBUG调试中一些常用的命令&lt;/p&gt;
&lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;window 10中好像已经没有了D
      
    
    </summary>
    
      <category term="汇编" scheme="https://www.vhcffh.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://www.vhcffh.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="DEBUG" scheme="https://www.vhcffh.com/tags/DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>Git使用中的一些问题</title>
    <link href="https://www.vhcffh.com/2018/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://www.vhcffh.com/2018/Git使用中的一些问题/</id>
    <published>2018-01-22T02:01:00.000Z</published>
    <updated>2019-08-08T15:22:00.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-配置问题"><a href="#1-配置问题" class="headerlink" title="1.配置问题"></a>1.配置问题</h3><p>全局配置</p><pre><code class="lang-shell">$ git config --list  查看当前用户信息$ git config --global user.name &quot;username&quot; 配置用户名$ git config --global user.email emailname@example.com 配置邮箱</code></pre><p>项目配置(进入项目目录)</p><pre><code class="lang-shell">$ cat .git/config  项目配置信息$ git config  user.name &quot;username&quot; 配置用户名$ git config  user.email emailname@example.com 配置邮箱</code></pre><p>全局的配置就是加上—global<br>项目未设置的配置默认使用全局配置</p><h3 id="2-密钥问题"><a href="#2-密钥问题" class="headerlink" title="2.密钥问题"></a>2.密钥问题</h3><pre><code>$ cd ~/.ssh  查看是否存在密钥$ ssh-keygen -t rsa -C &quot;emailname@example.com&quot; 生成密钥$ ssh -T git@github.com  测试是否配置成功</code></pre><p>生成密钥过程中回车三次，是密码为空，不然每次push都要输入密码<br>生成密钥后主要有两个文件<br>~/.ssh/id_rsa<br>私钥进行处理后的一些内容<br>~/.ssh/id_rsa.pub<br>公钥进行处理后的内容，提交到服务器(github或coding)的内容<br>~/.ssh/known_hosts<br>这个文件可能会有，是ssh对服务器的一些记录</p><h3 id="3-工作区、暂存区和版本库"><a href="#3-工作区、暂存区和版本库" class="headerlink" title="3.工作区、暂存区和版本库"></a>3.工作区、暂存区和版本库</h3><p><img src="/images/2019/5_19_git.jpg" alt="img"></p><p><code>git add</code>：暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p><p><code>git commit</code>：暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p><p><code>git reset HEAD</code> ：暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p><p><code>git rm --cached &lt;file&gt;</code>：直接从暂存区删除文件，工作区则不做出改变。</p><p><code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code>：用暂存区全部或指定的文件替换工作区的文件。<strong>这个操作很危险，会清除工作区中未添加到暂存区的改动。</strong></p><p><code>git checkout HEAD .</code>或者 <code>git checkout HEAD &lt;file&gt;</code>：用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。<strong>这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-配置问题&quot;&gt;&lt;a href=&quot;#1-配置问题&quot; class=&quot;headerlink&quot; title=&quot;1.配置问题&quot;&gt;&lt;/a&gt;1.配置问题&lt;/h3&gt;&lt;p&gt;全局配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-shell&quot;&gt;$ git config --
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/Linux/"/>
    
    
      <category term="git" scheme="https://www.vhcffh.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>简单了解汇编</title>
    <link href="https://www.vhcffh.com/2018/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96/"/>
    <id>https://www.vhcffh.com/2018/简单了解汇编/</id>
    <published>2018-01-11T02:01:00.000Z</published>
    <updated>2019-08-08T15:21:06.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-汇编是什么"><a href="#1-汇编是什么" class="headerlink" title="1.汇编是什么"></a>1.汇编是什么</h3><p>汇编语言的主体是汇编指令，汇编指令是由机器指令发展而来，例如：<br>操作：将寄存器bx的内容送到ax<br>机器指令：101100000000000000000011<br>记起来太过于复杂，从而有了替代它的<br>汇编指令：<code>mov ax,bx</code><br>方便记忆，也符合人们的逻辑思维<br>程序员们编写汇编指令，在通过编译器编译成机器指令，然后就可以在计算机中运行了（如今的大部分高级语言是通过编译器，将高级语言转换成汇编语言，在编译成机器语言在电脑中运行）<br>不管什么语言，都要转换成机器语言在电脑中运行，汇编语言和高级语言都是人们为了简化程序制作过程而已  </p><h3 id="2-计算机的总线"><a href="#2-计算机的总线" class="headerlink" title="2.计算机的总线"></a>2.计算机的总线</h3><p>从逻辑上总线分为三类（8086）<br>数据总线：传送数据，总线宽度决定一次读取数据多少（16）<br>地址总线：指定地址，总线宽度决定寻址能力（20）<br>控制总线：控制读写  </p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>RAM：程序和数据都要加载到RAM即内存中，才能通过CPU运行，可读可写<br>ROM：一些芯片的主要参数，及操作指令，芯片出厂时已经固定，仅可读<br>计算机运行时，全部程序和数据都要加载到RAM中<br>通过ROM中的一些必要信息，CPU才能对外设进行操作  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-汇编是什么&quot;&gt;&lt;a href=&quot;#1-汇编是什么&quot; class=&quot;headerlink&quot; title=&quot;1.汇编是什么&quot;&gt;&lt;/a&gt;1.汇编是什么&lt;/h3&gt;&lt;p&gt;汇编语言的主体是汇编指令，汇编指令是由机器指令发展而来，例如：&lt;br&gt;操作：将寄存器bx的内容送到a
      
    
    </summary>
    
      <category term="汇编" scheme="https://www.vhcffh.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://www.vhcffh.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="x8086" scheme="https://www.vhcffh.com/tags/x8086/"/>
    
  </entry>
  
  <entry>
    <title>python遇到的错误</title>
    <link href="https://www.vhcffh.com/2017/python%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://www.vhcffh.com/2017/python遇到的错误/</id>
    <published>2017-12-26T02:01:00.000Z</published>
    <updated>2019-08-09T13:01:17.322Z</updated>
    
    <content type="html"><![CDATA[<p>python使用在中遇到的错误</p><h3 id="1-DLL-load-failed"><a href="#1-DLL-load-failed" class="headerlink" title="1.DLL load failed"></a>1.DLL load failed</h3><p><font color="red">python ImportError: DLL load failed: %1 不是有效的 Win32 应用程序</font><br>解决方法：去下载与你所安装的Python版本对应的pywin32并安装<br>下载链接：<a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a><br>对应版本和位数<br>Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:42:59) [MSC v.1500 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.<br>还有一种可能是导入的模块是64位的，而你的python是32位的  </p><h3 id="2-使用libsvm-for-python时出错-1"><a href="#2-使用libsvm-for-python时出错-1" class="headerlink" title="2.使用libsvm for python时出错[1]"></a>2.使用libsvm for python时出错[1]</h3><pre><code class="lang-shell">Traceback (most recent call last):  File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 28, in &lt;module&gt;    libsvm = CDLL(path.join(dirname, r&#39;..\windows\libsvm.dll&#39;))  File &quot;C:\Python36\lib\ctypes\__init__.py&quot;, line 348, in __init__    self._handle = _dlopen(self._name, mode)OSError: [WinError 126] 找不到指定的模块。During handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;train.py&quot;, line 3, in &lt;module&gt;    from libsvm.python.svmutil import *  File &quot;C:\Python36\lib\libsvm\python\svmutil.py&quot;, line 5, in &lt;module&gt;    from svm import *  File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 38, in &lt;module&gt;    raise Exception(&#39;LIBSVM library not found.&#39;)Exception: LIBSVM library not found.</code></pre><p>出错原因：在github上下载的libsvm中的libsvm.lib是win64版本的，而自己的python版本是32位的<br>解决方案：<br>方法1.更换python版本（太麻烦了，还要重新下载好多库）<br>方法2.去<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">万能宝库</a>上下载对应版本的.whl文件，（不用安装）直接解压后找到<a href="https://download.lfd.uci.edu/pythonlibs/o4uhg4xd/libsvm-3.22-cp27-cp27m-win32.whl" target="_blank" rel="noopener">libsvm.lib</a>更换即可<br>2018-09-07 22:11:58</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://blog.csdn.net/rena521/article/details/51187981" target="_blank" rel="noopener">https://blog.csdn.net/rena521/article/details/51187981</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python使用在中遇到的错误&lt;/p&gt;
&lt;h3 id=&quot;1-DLL-load-failed&quot;&gt;&lt;a href=&quot;#1-DLL-load-failed&quot; class=&quot;headerlink&quot; title=&quot;1.DLL load failed&quot;&gt;&lt;/a&gt;1.DLL load f
      
    
    </summary>
    
      <category term="Python" scheme="https://www.vhcffh.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.vhcffh.com/tags/python/"/>
    
      <category term="libsvm" scheme="https://www.vhcffh.com/tags/libsvm/"/>
    
  </entry>
  
  <entry>
    <title>位运算的妙用之二进制1的个数</title>
    <link href="https://www.vhcffh.com/2017/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.vhcffh.com/2017/位运算的妙用之二进制1的个数/</id>
    <published>2017-12-26T02:01:00.000Z</published>
    <updated>2019-08-09T13:03:15.271Z</updated>
    
    <content type="html"><![CDATA[<p>求出一个正整数转换成二进制形式中数字”1”的个数<br>题目：求出一个正整数转换成二进制形式中数字”1”的个数<br>如：<br>int 型数值为 80<br>转化成二进制形式：80 = 00000000 00000000 00000000 01010000<br>因此 1 的个数为 2  </p><h3 id="0-普通解法"><a href="#0-普通解法" class="headerlink" title="0.普通解法"></a>0.普通解法</h3><p>一位一位判断</p><pre><code class="lang-c">int bitCount1(int n) {    int count = 0;    while (n != 0) {        if (n &amp; 0x01 == 1)            count++;        n = n &gt;&gt; 1;    }    return count;}</code></pre><h3 id="2-大神的解法"><a href="#2-大神的解法" class="headerlink" title="2.大神的解法"></a>2.大神的解法</h3><pre><code class="lang-c">int bitCount2(int n) {    n = n - ((n &gt;&gt; 1) &amp; 0x55555555);//n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333);    n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f);    n = n + (n &gt;&gt; 8);               //n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff);    n = n + (n &gt;&gt; 16);              //n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff);    return n &amp; 0x0000003f;          //return n;}</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1.<a href="https://www.jianshu.com/p/25c75149e7a2" target="_blank" rel="noopener">https://www.jianshu.com/p/25c75149e7a2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;求出一个正整数转换成二进制形式中数字”1”的个数&lt;br&gt;题目：求出一个正整数转换成二进制形式中数字”1”的个数&lt;br&gt;如：&lt;br&gt;int 型数值为 80&lt;br&gt;转化成二进制形式：80 = 00000000 00000000 00000000 01010000&lt;br&gt;因此 1
      
    
    </summary>
    
      <category term="C/C++" scheme="https://www.vhcffh.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="https://www.vhcffh.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="算法" scheme="https://www.vhcffh.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言文件读写</title>
    <link href="https://www.vhcffh.com/2017/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>https://www.vhcffh.com/2017/C语言文件读写/</id>
    <published>2017-12-21T02:01:00.000Z</published>
    <updated>2019-08-09T12:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>C语言文件操作笔记</p><pre><code class="lang-c">FILE *fopen(char *filename,char *type); //打开文件int fclose(FILE *stream); //关闭文件int fgetc(FILE *stream); //读一个字符指针后移int getc(FILE *stream);int fputc(int ch,FILE *stream); //写一个字符指针后移int putc(int ch,FILE *stream);</code></pre><p>filename指明文件路径<br>type可取的至如下<br>“r” :打开一个已有的文本文，允许读取文件<br>“w” :打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容<br>“a” :打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。<br>“r+”:打开一个文本文件，允许读写文件<br>“w+”:打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件<br>“a+”:打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式<br>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式:<br><code>&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言文件操作笔记&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;FILE *fopen(char *filename,char *type); //打开文件
int fclose(FILE *stream); //关闭文件
int fgetc(FILE *s
      
    
    </summary>
    
      <category term="C/C++" scheme="https://www.vhcffh.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="https://www.vhcffh.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="文件" scheme="https://www.vhcffh.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>sublime_Text3插入当前时间</title>
    <link href="https://www.vhcffh.com/2017/sublime_Text3%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/"/>
    <id>https://www.vhcffh.com/2017/sublime_Text3插入当前时间/</id>
    <published>2017-12-21T02:01:00.000Z</published>
    <updated>2019-08-09T13:01:51.831Z</updated>
    
    <content type="html"><![CDATA[<p>sublime_Text3插入当前时间</p><h3 id="1-创建新snippet"><a href="#1-创建新snippet" class="headerlink" title="1.创建新snippet"></a>1.创建新snippet</h3><p>tool → new snippet 创建一个新的snippet,并保存为”author.sublime-snippet”(最好在该目录(User)下再创建一个MySnippet目录):<br>其内容:  </p><pre><code class="lang-xml">&lt;snippet&gt;&lt;content&gt;&lt;![CDATA[/** * ============================ * @Author:   XX * @Version:  1.0  * @DateTime: ${1:alt+t} * ============================ */]]&gt;&lt;/content&gt;    &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;    &lt;tabTrigger&gt;author&lt;/tabTrigger&gt;    &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;    &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt;</code></pre><h3 id="2-创建新插件"><a href="#2-创建新插件" class="headerlink" title="2.创建新插件"></a>2.创建新插件</h3><p>Tools → New Plugin. 创建时间插件,保存在User目录,命名为addCurrentTime.py:<br>其内容为:  </p><pre><code class="lang-python">import sublime, sublime_pluginimport datetimeclass AddCurrentTimeCommand(sublime_plugin.TextCommand):    def run(self, edit):        self.view.run_command(&quot;insert_snippet&quot;,             {                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)             }        )</code></pre><h3 id="3-绑定快捷键"><a href="#3-绑定快捷键" class="headerlink" title="3.绑定快捷键"></a>3.绑定快捷键</h3><p>Preference → Key Bindings → User.绑定快捷键:  </p><pre><code>[    {        &quot;command&quot;: &quot;add_current_time&quot;,        &quot;keys&quot;: [            &quot;alt+t&quot;        ]    }]</code></pre><p>其中绑定的命令的名字是由所创建的插件的类名而来<br>AddCurrentTimeCommand—&gt;add_current_time<br>这应该是Sublime创建插件的规则  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1,<a href="http://www.cnblogs.com/xiaomingzaixian/p/6984664.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaomingzaixian/p/6984664.html</a><br>2,<a href="http://blog.csdn.net/sshfl_csdn/article/details/46415551" target="_blank" rel="noopener">http://blog.csdn.net/sshfl_csdn/article/details/46415551</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sublime_Text3插入当前时间&lt;/p&gt;
&lt;h3 id=&quot;1-创建新snippet&quot;&gt;&lt;a href=&quot;#1-创建新snippet&quot; class=&quot;headerlink&quot; title=&quot;1.创建新snippet&quot;&gt;&lt;/a&gt;1.创建新snippet&lt;/h3&gt;&lt;p&gt;too
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.vhcffh.com/categories/Linux/"/>
    
    
      <category term="sublime" scheme="https://www.vhcffh.com/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="https://www.vhcffh.com/2017/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>https://www.vhcffh.com/2017/字符串匹配/</id>
    <published>2017-12-21T02:01:00.000Z</published>
    <updated>2019-08-09T13:05:08.371Z</updated>
    
    <content type="html"><![CDATA[<p>从左到右依次比较<br>s:主串<br>r:模式串  </p><pre><code class="lang-c">int BM(char *s,int slen,char *r,int rlen){    int i=1,j=1;    while(i&lt;=slen-rlen+1){        while(j&lt;=rlen&amp;&amp;s[i]==r[j]){            i++;j++;        }        if(j&gt;rlen){            return i-j+1;        }else{            j=1;i++;        }    }    return 0;}</code></pre><h1 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h1><p>通过一个next数字<br>当每次发生不匹配的时候<br>模式串不必回到开头  </p><pre><code class="lang-c">int* getnext(char *r, int n) { //next数组求解    int i, j;    int *next = (int *)malloc((n + 1) * sizeof(int));    next[0] = n; next[1] = 0;    j = 0;    i=1;    while(i&lt;n){        if (j == 0 || r[i] == r[j]) {            ++i; ++j;            next[i] = j;        } else {            j = next[j];        }    }    return next;}int KMP(char *s,int slen,char *r,int rlen){    int *next=getnext(r,rlen);    int i=1,j=1;    while(i&lt;=slen&amp;&amp;j&lt;=rlen){        while(j&lt;=rlen&amp;&amp;s[i]==r[j]){            i++;j++;        }        if(j&gt;rlen){            return i-j+1;        }else{            j=next[j];i++;        }    }    return 0;}</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从左到右依次比较&lt;br&gt;s:主串&lt;br&gt;r:模式串  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;int BM(char *s,int slen,char *r,int rlen){
    int i=1,j=1;
    while(i&amp;lt;=sle
      
    
    </summary>
    
      <category term="算法" scheme="https://www.vhcffh.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C语言" scheme="https://www.vhcffh.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="算法" scheme="https://www.vhcffh.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
